\hypertarget{namespaceIceBRG_1_1tuples}{}\section{Ice\+B\+R\+G\+:\+:tuples Namespace Reference}
\label{namespaceIceBRG_1_1tuples}\index{Ice\+B\+R\+G\+::tuples@{Ice\+B\+R\+G\+::tuples}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper}{add\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_1_1tuc2970434d93561fa1e1db195cb99b491}{add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{add\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}{add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__NOT__TUPLE_07T2_08_4}{add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}{add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1asct__typeof__helper}{asct\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1asct__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}{asct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1asct__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{asct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper}{binary\+\_\+rand\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_5c02c427c306686c3b1206a9b133bf57}{binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, T, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01T1_00_01T2_00_01BRG__S__IS__TU17fb7ccd40b5d61da5648c1c2c034d10}{binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01T1_00_01T2_00_01BRG__S__IS__TU0ef4e05af1a56449fbbcc207cdc65c2c}{binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01T1_00_01T2_00_01BRG__S__NOT__Taf66ad01f9236805ac3540fbfcbdbe8d}{binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper}{divide\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_1_bd03af67120e73dd34936ad50f2c1b33}{divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{divide\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}{divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_086c96d3c3ec89211a6e76f31c5665b8a}{divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_08_f2134547733f778a855586b5d8107f2b}{divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1ipow__typeof__helper}{ipow\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1ipow__typeof__helper_3_01p_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{ipow\+\_\+typeof\+\_\+helper$<$ p, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1ipow__typeof__helper_3_01p_00_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{ipow\+\_\+typeof\+\_\+helper$<$ p, T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper}{multiply\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_3879c0d85d6ebd176aeb832142f492bd}{multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{multiply\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_081d8a4cfcf4cba4b6dba7b46ae822b392}{multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08d0dac86c84971415068079a4f4319b30}{multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_0f8b2bfe2074bcff168e50ce88774b3d8}{multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sct__typeof__helper}{sct\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sct__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}{sct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sct__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{sct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sqrt__typeof__helper}{sqrt\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sqrt__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}{sqrt\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sqrt__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{sqrt\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper}{subtract\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_80010c4fbaf3d761a5da3d020e0023b6}{subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{subtract\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08c8e4888bfd8d316092f0dc03c7128272}{subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08131694fe54a3c7a6002fbebfff754799}{subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_055529bde261c2acf7cf4746a6301cbf1}{subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1unary__rand__typeof__helper}{unary\+\_\+rand\+\_\+typeof\+\_\+helper}
\item 
struct \hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1unary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{unary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, void $>$}
\item 
struct \hyperlink{structIceBRG_1_1tuples_1_1unary__rand__typeof__helper_3_01f_00_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{unary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Th , typename Tt $>$ }\\boost\+::tuples\+::cons$<$ Th, Tt $>$ \hyperlink{namespaceIceBRG_1_1tuples_ac21b3a3433cc3c2ee33c4950b92689e6}{make\+\_\+cons} (Th \&\&h, Tt \&\&t)
\begin{DoxyCompactList}\small\item\em Helper function to construct a cons list with argument deduction. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Class Documentation}
\index{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1add__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:add\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class T1, class T2, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, Enable1, Enable2 $>$}

Helper structure to determine the type of adding two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1add__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_1_1tuc2970434d93561fa1e1db195cb99b491}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_1_1tuc2970434d93561fa1e1db195cb99b491}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:add\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$$>$struct Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a42185186c3594c65a4b8bfc24149ce2e}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a42185186c3594c65a4b8bfc24149ce2e}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$@{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}}\label{structIceBRG_1_1tuples_1_1add__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:add\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, T, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a0503c150c599461739fa22e618e07ece}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a0503c150c599461739fa22e618e07ece}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:add\+\_\+typeof\+\_\+helper$<$ T, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a061219a3f5427911524ac770ddc232eb}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a061219a3f5427911524ac770ddc232eb}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of adding two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_ae86ef7e43c4c8a4f94a25646b71e3b7e}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a8174c2af95d1a0d1dc44fff6d8c544e2}{type}\label{namespaceIceBRG_1_1tuples_ae86ef7e43c4c8a4f94a25646b71e3b7e}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a0d4426894c7f0b168a9e977776768c30}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a8174c2af95d1a0d1dc44fff6d8c544e2}{type}\label{namespaceIceBRG_1_1tuples_a0d4426894c7f0b168a9e977776768c30}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a8174c2af95d1a0d1dc44fff6d8c544e2}{}get\+\_\+tail()), decltype(\hyperlink{namespaceIceBRG_1_1tuples_a0d4426894c7f0b168a9e977776768c30}{T2d}()\label{namespaceIceBRG_1_1tuples_a8174c2af95d1a0d1dc44fff6d8c544e2}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__NOT__TUPLE_07T2_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__NOT__TUPLE_07T2_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of adding two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a12ae66934f161a5bf4f475165542b2f1}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a15f91e2e79b711689bbaff1a3f697909}{type}\label{namespaceIceBRG_1_1tuples_a12ae66934f161a5bf4f475165542b2f1}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a122bf8da284a5c5cf8a0bd39e95bf340}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a15f91e2e79b711689bbaff1a3f697909}{type}\label{namespaceIceBRG_1_1tuples_a122bf8da284a5c5cf8a0bd39e95bf340}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a15f91e2e79b711689bbaff1a3f697909}{}get\+\_\+head(), \hyperlink{namespaceIceBRG_1_1tuples_a122bf8da284a5c5cf8a0bd39e95bf340}{T2d}())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper}{add\+\_\+typeof\+\_\+helper}$<$ decltype(\hyperlink{namespaceIceBRG_1_1tuples_a12ae66934f161a5bf4f475165542b2f1}{T1d}()\label{namespaceIceBRG_1_1tuples_a15f91e2e79b711689bbaff1a3f697909}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::add\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of adding two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a4fb70245108f8c14684768b4f2ffbd5f}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_ad09c1743911cee7306fca7eeacb88b1d}{type}\label{namespaceIceBRG_1_1tuples_a4fb70245108f8c14684768b4f2ffbd5f}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a21e6c1a62f0b8388537f27edac9cedd6}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_ad09c1743911cee7306fca7eeacb88b1d}{type}\label{namespaceIceBRG_1_1tuples_a21e6c1a62f0b8388537f27edac9cedd6}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_ad09c1743911cee7306fca7eeacb88b1d}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1add__typeof__helper}{add\+\_\+typeof\+\_\+helper}$<$ \hyperlink{namespaceIceBRG_1_1tuples_a4fb70245108f8c14684768b4f2ffbd5f}{T1d}, \\*
decltype(\hyperlink{namespaceIceBRG_1_1tuples_a21e6c1a62f0b8388537f27edac9cedd6}{T2d}()\label{namespaceIceBRG_1_1tuples_ad09c1743911cee7306fca7eeacb88b1d}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1asct__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1asct__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:asct\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class T1, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper$<$ T1, Enable1, Enable2 $>$}

Helper structure to determine the type of scting a tuple. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1asct__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1asct__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:asct\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$$>$struct Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a9a6e4f934d283ccdc51be79f48c96f08}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a9a6e4f934d283ccdc51be79f48c96f08}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$@{Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}}\label{structIceBRG_1_1tuples_1_1asct__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1asct__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:asct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1)$>$}
\subsubsection*{template$<$class T1$>$struct Ice\+B\+R\+G\+::tuples\+::asct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}

Helper structure to determine the type of scting two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a727efa761d29eff947b1da46427e5bf8}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a1d496189651c53e9d2271ac49e503c2a}{type}\label{namespaceIceBRG_1_1tuples_a727efa761d29eff947b1da46427e5bf8}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a1d496189651c53e9d2271ac49e503c2a}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1asct__typeof__helper}{asct\+\_\+typeof\+\_\+helper}$<$ decltype(\hyperlink{namespaceIceBRG_1_1tuples_a727efa761d29eff947b1da46427e5bf8}{T1d}()\label{namespaceIceBRG_1_1tuples_a1d496189651c53e9d2271ac49e503c2a}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1binary__rand__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:binary\+\_\+rand\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class f, class T1, class T2, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T1, T2, Enable1, Enable2 $>$}

Helper structure to determine the type of generating a random tuple from a function. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_5c02c427c306686c3b1206a9b133bf57}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_5c02c427c306686c3b1206a9b133bf57}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+:\+:tuples\+:\+:null\+\_\+type, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$class f$>$struct Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a0236af1786620d7501c4b5dea46375f3}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a0236af1786620d7501c4b5dea46375f3}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, T, void $>$@{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, T, void $>$}}\label{structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+:\+:tuples\+:\+:null\+\_\+type, T, void $>$}
\subsubsection*{template$<$class f, typename T$>$struct Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, T, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a9fdd4714d412693da9a56de67fbb8faa}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a9fdd4714d412693da9a56de67fbb8faa}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1binary__rand__typeof__helper_3_01f_00_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$class f, typename T$>$struct Ice\+B\+R\+G\+::tuples\+::binary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a3f8d9d33739ad79e775208cdf6ebc2eb}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a3f8d9d33739ad79e775208cdf6ebc2eb}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1divide__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:divide\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class T1, class T2, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, Enable1, Enable2 $>$}

Helper structure to determine the type of divideing two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_1_bd03af67120e73dd34936ad50f2c1b33}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_1_bd03af67120e73dd34936ad50f2c1b33}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:divide\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$$>$struct Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a3b0c6a33f7c35a75c21f00d781ada664}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a3b0c6a33f7c35a75c21f00d781ada664}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$@{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}}\label{structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:divide\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, T, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a7cfc445edc292d533aa157bb68adeca7}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a7cfc445edc292d533aa157bb68adeca7}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:divide\+\_\+typeof\+\_\+helper$<$ T, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_aff0ca5b155cb513918ee25d96b94a9a8}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_aff0ca5b155cb513918ee25d96b94a9a8}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_00_01BRG__S__IS__TUPLE_07T2_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of divideing two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a5dd19ded108a7f6bd9a1b80f80ef27ef}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_ab30c942f5de4c1473701c0a3a7454453}{type}\label{namespaceIceBRG_1_1tuples_a5dd19ded108a7f6bd9a1b80f80ef27ef}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_acb789365c7ce7dbcbcb954d579bd4797}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_ab30c942f5de4c1473701c0a3a7454453}{type}\label{namespaceIceBRG_1_1tuples_acb789365c7ce7dbcbcb954d579bd4797}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_ab30c942f5de4c1473701c0a3a7454453}{}get\+\_\+tail()), decltype(\hyperlink{namespaceIceBRG_1_1tuples_acb789365c7ce7dbcbcb954d579bd4797}{T2d}()\label{namespaceIceBRG_1_1tuples_ab30c942f5de4c1473701c0a3a7454453}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_086c96d3c3ec89211a6e76f31c5665b8a}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08_086c96d3c3ec89211a6e76f31c5665b8a}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of divideing two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a8557420cff2527ee10fcebd5efec0dfa}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a81675a05e5b378685be3983580f2c6a5}{type}\label{namespaceIceBRG_1_1tuples_a8557420cff2527ee10fcebd5efec0dfa}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a8a492fc9ba9dac5f8715af9f44c019e2}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a81675a05e5b378685be3983580f2c6a5}{type}\label{namespaceIceBRG_1_1tuples_a8a492fc9ba9dac5f8715af9f44c019e2}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a81675a05e5b378685be3983580f2c6a5}{}get\+\_\+head(), \hyperlink{namespaceIceBRG_1_1tuples_a8a492fc9ba9dac5f8715af9f44c019e2}{T2d}())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper}{divide\+\_\+typeof\+\_\+helper}$<$ decltype(\hyperlink{namespaceIceBRG_1_1tuples_a8557420cff2527ee10fcebd5efec0dfa}{T1d}()\label{namespaceIceBRG_1_1tuples_a81675a05e5b378685be3983580f2c6a5}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_08_f2134547733f778a855586b5d8107f2b}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_08_f2134547733f778a855586b5d8107f2b}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::divide\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of divideing two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a33ba3919709592010628fa1516bd3b7b}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a94b4388c855c8a54d726c4045d1c1059}{type}\label{namespaceIceBRG_1_1tuples_a33ba3919709592010628fa1516bd3b7b}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a89ddecb81b091b33f9c2d07a9f6370a8}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a94b4388c855c8a54d726c4045d1c1059}{type}\label{namespaceIceBRG_1_1tuples_a89ddecb81b091b33f9c2d07a9f6370a8}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a94b4388c855c8a54d726c4045d1c1059}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1divide__typeof__helper}{divide\+\_\+typeof\+\_\+helper}$<$ \hyperlink{namespaceIceBRG_1_1tuples_a33ba3919709592010628fa1516bd3b7b}{T1d}, \\*
decltype(\hyperlink{namespaceIceBRG_1_1tuples_a89ddecb81b091b33f9c2d07a9f6370a8}{T2d}()\label{namespaceIceBRG_1_1tuples_a94b4388c855c8a54d726c4045d1c1059}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1ipow__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1ipow__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:ipow\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$int\+\_\+type p, class T1, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper$<$ p, T1, Enable1, Enable2 $>$}

Helper structure to determine the type of ipowing a tuple. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper$<$ p, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper$<$ p, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1ipow__typeof__helper_3_01p_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1ipow__typeof__helper_3_01p_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:ipow\+\_\+typeof\+\_\+helper$<$ p, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$int\+\_\+type p$>$struct Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper$<$ p, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a57be2e737cd2b0be82546d8aa85323c6}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a57be2e737cd2b0be82546d8aa85323c6}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper$<$ p, T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$@{Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper$<$ p, T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}}\label{structIceBRG_1_1tuples_1_1ipow__typeof__helper_3_01p_00_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1ipow__typeof__helper_3_01p_00_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:ipow\+\_\+typeof\+\_\+helper$<$ p, T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1)$>$}
\subsubsection*{template$<$int\+\_\+type p, class T1$>$struct Ice\+B\+R\+G\+::tuples\+::ipow\+\_\+typeof\+\_\+helper$<$ p, T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}

Helper structure to determine the type of ipowing two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a1368a0d7b4c47bd64f1f57c45a764085}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_aed1bfdd2be2297b3023a4480680a5ec0}{type}\label{namespaceIceBRG_1_1tuples_a1368a0d7b4c47bd64f1f57c45a764085}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_aed1bfdd2be2297b3023a4480680a5ec0}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1ipow__typeof__helper}{ipow\+\_\+typeof\+\_\+helper}$<$ p, \\*
decltype(\hyperlink{namespaceIceBRG_1_1tuples_a1368a0d7b4c47bd64f1f57c45a764085}{T1d}()\label{namespaceIceBRG_1_1tuples_aed1bfdd2be2297b3023a4480680a5ec0}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1multiply__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:multiply\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class T1, class T2, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, Enable1, Enable2 $>$}

Helper structure to determine the type of multiplying two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_3879c0d85d6ebd176aeb832142f492bd}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_3879c0d85d6ebd176aeb832142f492bd}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:multiply\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$$>$struct Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a7a2232870a048d62eef032f9e00bf7d9}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a7a2232870a048d62eef032f9e00bf7d9}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$@{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}}\label{structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:multiply\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, T, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a374ba5bed0de21d1567f5111293720ac}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a374ba5bed0de21d1567f5111293720ac}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:multiply\+\_\+typeof\+\_\+helper$<$ T, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a5105d0eef1d795e1a6213ed7c405592f}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a5105d0eef1d795e1a6213ed7c405592f}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_081d8a4cfcf4cba4b6dba7b46ae822b392}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_081d8a4cfcf4cba4b6dba7b46ae822b392}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of multiplying two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_aab307083c178318760b27db29f19cf65}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a364d75e832c65a371dae7fd6ae0702f9}{type}\label{namespaceIceBRG_1_1tuples_aab307083c178318760b27db29f19cf65}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_ae6c39ce39ba34e94adb6679a7304326e}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a364d75e832c65a371dae7fd6ae0702f9}{type}\label{namespaceIceBRG_1_1tuples_ae6c39ce39ba34e94adb6679a7304326e}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a364d75e832c65a371dae7fd6ae0702f9}{}get\+\_\+tail()), decltype(\hyperlink{namespaceIceBRG_1_1tuples_ae6c39ce39ba34e94adb6679a7304326e}{T2d}()\label{namespaceIceBRG_1_1tuples_a364d75e832c65a371dae7fd6ae0702f9}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08d0dac86c84971415068079a4f4319b30}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08d0dac86c84971415068079a4f4319b30}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of multiplying two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_aa2583e993d44e330d94823cd43602ad5}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_abea59dce5657fb6ea23a6f398a16b9ff}{type}\label{namespaceIceBRG_1_1tuples_aa2583e993d44e330d94823cd43602ad5}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a3a7c562e835b743e2e6b95a2449f30c1}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_abea59dce5657fb6ea23a6f398a16b9ff}{type}\label{namespaceIceBRG_1_1tuples_a3a7c562e835b743e2e6b95a2449f30c1}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_abea59dce5657fb6ea23a6f398a16b9ff}{}get\+\_\+head(), \hyperlink{namespaceIceBRG_1_1tuples_a3a7c562e835b743e2e6b95a2449f30c1}{T2d}())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper}{multiply\+\_\+typeof\+\_\+helper}\\*
$<$ decltype(\hyperlink{namespaceIceBRG_1_1tuples_aa2583e993d44e330d94823cd43602ad5}{T1d}()\label{namespaceIceBRG_1_1tuples_abea59dce5657fb6ea23a6f398a16b9ff}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_0f8b2bfe2074bcff168e50ce88774b3d8}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_0f8b2bfe2074bcff168e50ce88774b3d8}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::multiply\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of multiplying two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_aeb527db06a943494eb8e1b53b3bb1ac4}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a9a6a86c894d9573bf12cdca5810c7d31}{type}\label{namespaceIceBRG_1_1tuples_aeb527db06a943494eb8e1b53b3bb1ac4}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a2d1618c5821f55cdbd9b5a9d470ac18e}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a9a6a86c894d9573bf12cdca5810c7d31}{type}\label{namespaceIceBRG_1_1tuples_a2d1618c5821f55cdbd9b5a9d470ac18e}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a9a6a86c894d9573bf12cdca5810c7d31}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1multiply__typeof__helper}{multiply\+\_\+typeof\+\_\+helper}$<$ \hyperlink{namespaceIceBRG_1_1tuples_aeb527db06a943494eb8e1b53b3bb1ac4}{T1d}, \\*
decltype(\hyperlink{namespaceIceBRG_1_1tuples_a2d1618c5821f55cdbd9b5a9d470ac18e}{T2d}()\label{namespaceIceBRG_1_1tuples_a9a6a86c894d9573bf12cdca5810c7d31}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1sct__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sct__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:sct\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class T1, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper$<$ T1, Enable1, Enable2 $>$}

Helper structure to determine the type of scting a tuple. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1sct__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sct__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:sct\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$$>$struct Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a5bdafd92e206713e6c9c567192e3be0b}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a5bdafd92e206713e6c9c567192e3be0b}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$@{Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}}\label{structIceBRG_1_1tuples_1_1sct__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sct__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:sct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1)$>$}
\subsubsection*{template$<$class T1$>$struct Ice\+B\+R\+G\+::tuples\+::sct\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}

Helper structure to determine the type of scting two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_aee11156a089e68658dbf646cee662dd9}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_ae8d44ac1b67db98010ff993be194c629}{type}\label{namespaceIceBRG_1_1tuples_aee11156a089e68658dbf646cee662dd9}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_ae8d44ac1b67db98010ff993be194c629}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sct__typeof__helper}{sct\+\_\+typeof\+\_\+helper}$<$ decltype(\hyperlink{namespaceIceBRG_1_1tuples_aee11156a089e68658dbf646cee662dd9}{T1d}()\label{namespaceIceBRG_1_1tuples_ae8d44ac1b67db98010ff993be194c629}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1sqrt__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sqrt__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:sqrt\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class T1, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper$<$ T1, Enable1, Enable2 $>$}

Helper structure to determine the type of sqrting a tuple. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1sqrt__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sqrt__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:sqrt\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$$>$struct Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a18937c38bf20064bca7041e358671bfc}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a18937c38bf20064bca7041e358671bfc}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$@{Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}}\label{structIceBRG_1_1tuples_1_1sqrt__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sqrt__typeof__helper_3_01T1_00_01BRG__S__IS__TUPLE_07T1_08_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:sqrt\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1)$>$}
\subsubsection*{template$<$class T1$>$struct Ice\+B\+R\+G\+::tuples\+::sqrt\+\_\+typeof\+\_\+helper$<$ T1, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1)$>$}

Helper structure to determine the type of sqrting two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a72b5de2684a13e04d40d8c4d99c449a5}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a0a6b119c6ecb453a52b9c4e9a7dc9942}{type}\label{namespaceIceBRG_1_1tuples_a72b5de2684a13e04d40d8c4d99c449a5}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a0a6b119c6ecb453a52b9c4e9a7dc9942}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1sqrt__typeof__helper}{sqrt\+\_\+typeof\+\_\+helper}$<$ decltype(\hyperlink{namespaceIceBRG_1_1tuples_a72b5de2684a13e04d40d8c4d99c449a5}{T1d}()\label{namespaceIceBRG_1_1tuples_a0a6b119c6ecb453a52b9c4e9a7dc9942}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1subtract__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:subtract\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class T1, class T2, class Enable1 = void, class Enable2 = void$>$struct Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, Enable1, Enable2 $>$}

Helper structure to determine the type of subtracting two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_80010c4fbaf3d761a5da3d020e0023b6}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01boost_80010c4fbaf3d761a5da3d020e0023b6}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:subtract\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$$>$struct Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a57bea50e4b845e4dc575c3f382d6a774}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a57bea50e4b845e4dc575c3f382d6a774}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$@{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}}\label{structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01boost_1_1tuples_1_1null__type_00_01T_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:subtract\+\_\+typeof\+\_\+helper$<$ boost\+:\+:tuples\+:\+:null\+\_\+type, T, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ boost\+::tuples\+::null\+\_\+type, T, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_af35e1afe4efe44b31e066cecedb2f275}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_af35e1afe4efe44b31e066cecedb2f275}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:subtract\+\_\+typeof\+\_\+helper$<$ T, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$typename T$>$struct Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a3ac5f6d7ed167ef5757b624c09149f96}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a3ac5f6d7ed167ef5757b624c09149f96}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08c8e4888bfd8d316092f0dc03c7128272}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08c8e4888bfd8d316092f0dc03c7128272}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of subtracting two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a1b8bb4d7aee76ef5720b840bcf38e892}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a31f2a5c17258aa6e326dc7423d396485}{type}\label{namespaceIceBRG_1_1tuples_a1b8bb4d7aee76ef5720b840bcf38e892}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a3e7f1fdd6036bc7e27edaeecc8916b4a}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a31f2a5c17258aa6e326dc7423d396485}{type}\label{namespaceIceBRG_1_1tuples_a3e7f1fdd6036bc7e27edaeecc8916b4a}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a31f2a5c17258aa6e326dc7423d396485}{}get\+\_\+tail()), decltype(\hyperlink{namespaceIceBRG_1_1tuples_a3e7f1fdd6036bc7e27edaeecc8916b4a}{T2d}()\label{namespaceIceBRG_1_1tuples_a31f2a5c17258aa6e326dc7423d396485}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08131694fe54a3c7a6002fbebfff754799}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__IS__TUPLE_07T1_08131694fe54a3c7a6002fbebfff754799}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of subtracting two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a24369ce989b2bc35403b5197404686cb}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_aff9a31e443e09ed188186e3de584ea5d}{type}\label{namespaceIceBRG_1_1tuples_a24369ce989b2bc35403b5197404686cb}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a982e856de804f5226aedec5e50568fde}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_aff9a31e443e09ed188186e3de584ea5d}{type}\label{namespaceIceBRG_1_1tuples_a982e856de804f5226aedec5e50568fde}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_aff9a31e443e09ed188186e3de584ea5d}{}get\+\_\+head(), \hyperlink{namespaceIceBRG_1_1tuples_a982e856de804f5226aedec5e50568fde}{T2d}())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper}{subtract\+\_\+typeof\+\_\+helper}\\*
$<$ decltype(\hyperlink{namespaceIceBRG_1_1tuples_a24369ce989b2bc35403b5197404686cb}{T1d}()\label{namespaceIceBRG_1_1tuples_aff9a31e443e09ed188186e3de584ea5d}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$@{Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}}\label{structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_055529bde261c2acf7cf4746a6301cbf1}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper_3_01T1_00_01T2_00_01BRG__S__NOT__TUPLE_07T1_055529bde261c2acf7cf4746a6301cbf1}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(T2)$>$}
\subsubsection*{template$<$class T1, class T2$>$struct Ice\+B\+R\+G\+::tuples\+::subtract\+\_\+typeof\+\_\+helper$<$ T1, T2, B\+R\+G\+\_\+\+S\+\_\+\+N\+O\+T\+\_\+\+T\+U\+P\+L\+E(\+T1), B\+R\+G\+\_\+\+S\+\_\+\+I\+S\+\_\+\+T\+U\+P\+L\+E(\+T2)$>$}

Helper structure to determine the type of subtracting two values or tuples together. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a3a6088841c87612c4979848427bbfffa}{}typedef decay$<$ T1 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a456742eecd7ca819fae5ff7f63a4b789}{type}\label{namespaceIceBRG_1_1tuples_a3a6088841c87612c4979848427bbfffa}
&
T1d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a20517a7169e509c9854375d1329461b8}{}typedef decay$<$ T2 $>$\+::\hyperlink{namespaceIceBRG_1_1tuples_a456742eecd7ca819fae5ff7f63a4b789}{type}\label{namespaceIceBRG_1_1tuples_a20517a7169e509c9854375d1329461b8}
&
T2d&
\\
\hline

\hypertarget{namespaceIceBRG_1_1tuples_a456742eecd7ca819fae5ff7f63a4b789}{}get\+\_\+head())), typename \\*
\hyperlink{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1subtract__typeof__helper}{subtract\+\_\+typeof\+\_\+helper}$<$ \hyperlink{namespaceIceBRG_1_1tuples_a3a6088841c87612c4979848427bbfffa}{T1d}, \\*
decltype(\hyperlink{namespaceIceBRG_1_1tuples_a20517a7169e509c9854375d1329461b8}{T2d}()\label{namespaceIceBRG_1_1tuples_a456742eecd7ca819fae5ff7f63a4b789}
&
type&
\\
\hline

\end{DoxyFields}
\index{Ice\+B\+R\+G\+::tuples\+::unary\+\_\+rand\+\_\+typeof\+\_\+helper@{Ice\+B\+R\+G\+::tuples\+::unary\+\_\+rand\+\_\+typeof\+\_\+helper}}\label{structIceBRG_1_1tuples_1_1unary__rand__typeof__helper}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1unary__rand__typeof__helper}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:unary\+\_\+rand\+\_\+typeof\+\_\+helper}
\subsubsection*{template$<$class f, class T1, class Enable1 = void$>$struct Ice\+B\+R\+G\+::tuples\+::unary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, T1, Enable1 $>$}

Helper structure to determine the type of generating a random tuple from a function. This is needed since the compiler won\textquotesingle{}t fully recurse function decltypes, but it will fully recurse a structure. \index{Ice\+B\+R\+G\+::tuples\+::unary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, void $>$@{Ice\+B\+R\+G\+::tuples\+::unary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, void $>$}}\label{structIceBRG_1_1tuples_1_1unary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}
\hypertarget{namespaceIceBRG_1_1tuples_structIceBRG_1_1tuples_1_1unary__rand__typeof__helper_3_01f_00_01boost_1_1tuples_1_1null__type_00_01void_01_4}{}
\subsubsection{struct Ice\+B\+R\+G\+:\+:tuples\+:\+:unary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+:\+:tuples\+:\+:null\+\_\+type, void $>$}
\subsubsection*{template$<$class f$>$struct Ice\+B\+R\+G\+::tuples\+::unary\+\_\+rand\+\_\+typeof\+\_\+helper$<$ f, boost\+::tuples\+::null\+\_\+type, void $>$}

Null type overload to end recursion. \begin{DoxyFields}{Class Members}
\hypertarget{namespaceIceBRG_1_1tuples_a797e7251aa26c898d15325e9892931f5}{}typedef null\+\_\+type\label{namespaceIceBRG_1_1tuples_a797e7251aa26c898d15325e9892931f5}
&
type&
\\
\hline

\end{DoxyFields}


\subsection{Function Documentation}
\hypertarget{namespaceIceBRG_1_1tuples_ac21b3a3433cc3c2ee33c4950b92689e6}{}\index{Ice\+B\+R\+G\+::tuples@{Ice\+B\+R\+G\+::tuples}!make\+\_\+cons@{make\+\_\+cons}}
\index{make\+\_\+cons@{make\+\_\+cons}!Ice\+B\+R\+G\+::tuples@{Ice\+B\+R\+G\+::tuples}}
\subsubsection[{make\+\_\+cons(\+Th \&\&h, Tt \&\&t)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Th , typename Tt $>$ boost\+::tuples\+::cons$<$Th,Tt$>$ Ice\+B\+R\+G\+::tuples\+::make\+\_\+cons (
\begin{DoxyParamCaption}
\item[{Th \&\&}]{h, }
\item[{Tt \&\&}]{t}
\end{DoxyParamCaption}
)}\label{namespaceIceBRG_1_1tuples_ac21b3a3433cc3c2ee33c4950b92689e6}


Helper function to construct a cons list with argument deduction. 

