.TH "IceBRG" 3 "Thu Jul 9 2015" "Version 0.9.2" "CFHTLenS_Magnification" \" -*- nroff -*-
.ad l
.nh
.SH NAME
IceBRG \- 
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBFourier\fP"
.br
.ti -1c
.RI "namespace \fBsgsmooth\fP"
.br
.ti -1c
.RI "namespace \fBtuples\fP"
.br
.ti -1c
.RI "namespace \fBtwo_halo_calcs\fP"
.br
.ti -1c
.RI "namespace \fBunitconv\fP"
.br
.in -1c
.SS "Data Structures"

.in +1c
.ti -1c
.RI "class \fBcount_fitting_functor\fP"
.br
.ti -1c
.RI "class \fBSchechter_like_functor\fP"
.br
.ti -1c
.RI "class \fBlens_source_pair\fP"
.br
.ti -1c
.RI "class \fBlensing_profile_extension\fP"
.br
.ti -1c
.RI "class \fBprojected_density_functor\fP"
.br
.ti -1c
.RI "class \fBcylindrical_density_functor\fP"
.br
.ti -1c
.RI "class \fBoffset_ring_dens_functor\fP"
.br
.ti -1c
.RI "class \fBoffset_circ_dens_functor\fP"
.br
.ti -1c
.RI "class \fBoffset_Delta_Sigma_functor\fP"
.br
.ti -1c
.RI "class \fBquick_offset_Delta_Sigma_functor\fP"
.br
.ti -1c
.RI "class \fBgroup_Delta_Sigma_weight_functor\fP"
.br
.ti -1c
.RI "class \fBshifted_Delta_Sigma_weight_functor\fP"
.br
.ti -1c
.RI "class \fBshifted_Delta_Sigma_circ_functor\fP"
.br
.ti -1c
.RI "class \fBshifted_Delta_Sigma_functor\fP"
.br
.ti -1c
.RI "class \fBtNFW_sig_cache\fP"
.br
.ti -1c
.RI "class \fBtNFW_offset_sig_cache\fP"
.br
.ti -1c
.RI "class \fBtNFW_group_sig_cache\fP"
.br
.ti -1c
.RI "class \fBtNFW_shifted_sig_cache\fP"
.br
.ti -1c
.RI "class \fBtNFW_Sigma_cache\fP"
.br
.ti -1c
.RI "class \fBtNFW_offset_Sigma_cache\fP"
.br
.ti -1c
.RI "class \fBtNFW_group_Sigma_cache\fP"
.br
.ti -1c
.RI "class \fBlensing_tNFW_profile\fP"
.br
.ti -1c
.RI "class \fBexpected_count_cache\fP"
.br
.ti -1c
.RI "class \fBexpected_count_derivative_cache\fP"
.br
.ti -1c
.RI "class \fBexpected_count_fit_loader\fP"
.br
.ti -1c
.RI "class \fBexpected_count_loader\fP"
.br
.ti -1c
.RI "class \fBmag_calibration_cache\fP"
.br
.ti -1c
.RI "class \fBmag_calibration_loader\fP"
.br
.ti -1c
.RI "class \fBmag_correlation_function_estimator\fP"
.br
.ti -1c
.RI "class \fBmag_signal_integral_cache\fP"
.br
.ti -1c
.RI "class \fBmag_weight_integral_cache\fP"
.br
.ti -1c
.RI "class \fBmag_expected_count_functor\fP"
.br
.ti -1c
.RI "class \fBmu_signal_integration_functor\fP"
.br
.ti -1c
.RI "class \fBmu_weight_integration_functor\fP"
.br
.ti -1c
.RI "struct \fBlens_id\fP"
.br
.ti -1c
.RI "class \fBpair_bin\fP"
.br
.ti -1c
.RI "class \fBpair_bin_summary\fP"
.br
.ti -1c
.RI "struct \fBlens_id_lt\fP"
.br
.ti -1c
.RI "class \fBpair_binner\fP"
.br
.ti -1c
.RI "class \fBpair_bins_summary\fP"
.br
.ti -1c
.RI "class \fBshifting_cache\fP"
.br
.ti -1c
.RI "class \fBshifting_loader\fP"
.br
.ti -1c
.RI "class \fBsource_galaxy\fP"
.br
.ti -1c
.RI "class \fBsource_obj\fP"
.br
.ti -1c
.RI "struct \fBassignment_coercer\fP"
.br
.ti -1c
.RI "struct \fBassignment_coercer< 0, container >\fP"
.br
.ti -1c
.RI "struct \fBrange_coercer\fP"
.br
.ti -1c
.RI "struct \fBrange_coercer< 1, container >\fP"
.br
.ti -1c
.RI "struct \fBrange_coercer< 0, container >\fP"
.br
.ti -1c
.RI "struct \fBct\fP"
.br
.ti -1c
.RI "class \fBelement_accessor\fP"
.br
.ti -1c
.RI "struct \fBall_flt_type\fP"
.br
.ti -1c
.RI "struct \fBall_flt_type< T, BRG_S_IS_STL(T)>\fP"
.br
.ti -1c
.RI "struct \fBall_flt_type< T, BRG_S_IS_EIGEN(T)>\fP"
.br
.ti -1c
.RI "struct \fBall_flt_type< T, BRG_S_IS_NULL(T)>\fP"
.br
.ti -1c
.RI "struct \fBall_flt_type< T, BRG_S_IS_TUPLE(T)>\fP"
.br
.ti -1c
.RI "class \fBinsertion_ordered_map\fP"
.br
.ti -1c
.RI "struct \fB_is_boost_tuple\fP"
.br
.ti -1c
.RI "struct \fB_is_boost_tuple< boost::tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9 > >\fP"
.br
.ti -1c
.RI "struct \fB_is_boost_tuple< boost::tuples::cons< TH, TT > >\fP"
.br
.ti -1c
.RI "struct \fB_is_boost_tuple< boost::tuples::null_type >\fP"
.br
.ti -1c
.RI "struct \fBis_boost_tuple\fP"
.br
.ti -1c
.RI "struct \fB_is_null_type\fP"
.br
.ti -1c
.RI "struct \fB_is_null_type< boost::tuples::null_type >\fP"
.br
.ti -1c
.RI "struct \fBis_null_type\fP"
.br
.ti -1c
.RI "struct \fBis_container\fP"
.br
.ti -1c
.RI "struct \fBis_container_or_boost_tuple\fP"
.br
.ti -1c
.RI "struct \fBis_scalar\fP"
.br
.ti -1c
.RI "struct \fBis_scalar_or_eigen\fP"
.br
.ti -1c
.RI "struct \fBis_eigen_container\fP"
.br
.ti -1c
.RI "struct \fBhas_const_iterator\fP"
.br
.ti -1c
.RI "struct \fBhas_iterator\fP"
.br
.ti -1c
.RI "struct \fBhas_begin_end\fP"
.br
.ti -1c
.RI "struct \fBis_stl_container\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_col_iterator\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_col_reference\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_element_iterator\fP"
.br
.ti -1c
.RI "struct \fBlabeled_array_iterator_chooser\fP"
.br
.ti -1c
.RI "struct \fBlabeled_array_iterator_chooser< value_type, Eigen::ColMajor >\fP"
.br
.ti -1c
.RI "struct \fBlabeled_array_iterator_chooser< value_type, Eigen::RowMajor >\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_raw_col_iterator\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_raw_row_iterator\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_row_iterator\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_row_reference\fP"
.br
.ti -1c
.RI "class \fBlabeled_array_vecs\fP"
.br
.ti -1c
.RI "class \fBlabeled_array\fP"
.br
.ti -1c
.RI "class \fBbrg_cache\fP"
.br
.ti -1c
.RI "class \fBbrg_cache_2d\fP"
.br
.ti -1c
.RI "class \fBbrg_cache_3d\fP"
.br
.ti -1c
.RI "class \fBbrg_cache_4d\fP"
.br
.ti -1c
.RI "class \fBbrg_cache_nd\fP"
.br
.ti -1c
.RI "class \fBfunctor\fP"
.br
.ti -1c
.RI "class \fBfunctor_product\fP"
.br
.ti -1c
.RI "class \fBinterpolator\fP"
.br
.ti -1c
.RI "class \fBinterpolator_derivative\fP"
.br
.ti -1c
.RI "struct \fB_ipow_s\fP"
.br
.ti -1c
.RI "struct \fB_ipow_s< 1 >\fP"
.br
.ti -1c
.RI "struct \fB_ipow_s< 0 >\fP"
.br
.ti -1c
.RI "class \fBMCMC_solver\fP"
.br
.ti -1c
.RI "class \fBbootstrap\fP"
.br
.ti -1c
.RI "class \fBjackknife\fP"
.br
.ti -1c
.RI "class \fBlimit_vector\fP"
.br
.ti -1c
.RI "struct \fBvector_defaulter\fP"
.br
.ti -1c
.RI "struct \fBvector_defaulter< 1, container, other_container >\fP"
.br
.ti -1c
.RI "struct \fBvector_defaulter< 0, container, other_container >\fP"
.br
.ti -1c
.RI "struct \fBvector_zeroer\fP"
.br
.ti -1c
.RI "struct \fBvector_zeroer< 1, container, other_container >\fP"
.br
.ti -1c
.RI "struct \fBvector_zeroer< 0, container, other_container >\fP"
.br
.ti -1c
.RI "struct \fBvector_valuer\fP"
.br
.ti -1c
.RI "struct \fBvector_valuer< 1, container, value_type, other_container >\fP"
.br
.ti -1c
.RI "struct \fBvector_valuer< 0, container, value_type, other_container >\fP"
.br
.ti -1c
.RI "struct \fBvector_functioner\fP"
.br
.ti -1c
.RI "struct \fBvector_functioner< 1, container, func_type, other_container >\fP"
.br
.ti -1c
.RI "struct \fBvector_functioner< 0, container, func_type, other_container >\fP"
.br
.ti -1c
.RI "class \fBmulti_vector\fP"
.br
.ti -1c
.RI "class \fBredshift_obj\fP"
.br
.ti -1c
.RI "class \fBdfa_cache\fP"
.br
.ti -1c
.RI "class \fBadd_cache\fP"
.br
.ti -1c
.RI "class \fBtfa_cache\fP"
.br
.ti -1c
.RI "class \fBcorrelation_function_estimator\fP"
.br
.ti -1c
.RI "class \fBdensity_profile\fP"
.br
.ti -1c
.RI "class \fBaccel_functor\fP"
.br
.ti -1c
.RI "class \fBsolve_rhm_functor\fP"
.br
.ti -1c
.RI "class \fBspherical_density_functor\fP"
.br
.ti -1c
.RI "class \fBpoint_mass_profile\fP"
.br
.ti -1c
.RI "class \fBtNFW_profile\fP"
.br
.ti -1c
.RI "class \fBtNFW_solve_rvir_iterative_functor\fP"
.br
.ti -1c
.RI "class \fBtNFW_solve_rvir_minimize_functor\fP"
.br
.ti -1c
.RI "class \fBlensing_correlation_function_estimator\fP"
.br
.ti -1c
.RI "struct \fBphase\fP"
.br
.ti -1c
.RI "class \fBgalaxy\fP"
.br
.ti -1c
.RI "class \fBgalaxy_group\fP"
.br
.ti -1c
.RI "class \fBgrid_cache\fP"
.br
.ti -1c
.RI "class \fBposition_grid_extension\fP"
.br
.ti -1c
.RI "class \fBsky_obj\fP"
.br
.ti -1c
.RI "class \fBtNFW_galaxy\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef custom_unit_type< 0, 0, 0,-2, 0 > \fBinverse_square_angle\fP"
.br
.ti -1c
.RI "typedef std::vector< std::string > \fBheader_t\fP"
.br
.ti -1c
.RI "typedef Eigen::Array< \fBflt_type\fP, 
.br
Eigen::Dynamic, 1 > \fBflt_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBlong_flt_type\fP, 
.br
Eigen::Dynamic, 1 > \fBlong_flt_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array< \fBint_type\fP, 
.br
Eigen::Dynamic, 1 > \fBint_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBlong_int_type\fP, 
.br
Eigen::Dynamic, 1 > \fBlong_int_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBshort_int_type\fP, 
.br
Eigen::Dynamic, 1 > \fBshort_int_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBunsigned_int_type\fP, 
.br
Eigen::Dynamic, 1 > \fBunsigned_int_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBlong_unsigned_int_type\fP, 
.br
Eigen::Dynamic, 1 > \fBlong_unsigned_int_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBshort_unsigned_int_type\fP, 
.br
Eigen::Dynamic, 1 > \fBshort_unsigned_int_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBcomplex_type\fP, Eigen::Dynamic, 1 > \fBcomplex_array_type\fP"
.br
.ti -1c
.RI "typedef Eigen::Array
.br
< \fBlong_complex_type\fP, 
.br
Eigen::Dynamic, 1 > \fBlong_complex_array_type\fP"
.br
.ti -1c
.RI "typedef std::map< std::string, 
.br
\fBflt_type\fP > \fBunitconv_map\fP"
.br
.ti -1c
.RI "typedef boost::any \fBany_units_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::dimensionless > \fBdimensionless_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::length > \fBdistance_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::area > \fBarea_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::wavenumber > \fBinverse_distance_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::time > \fBtime_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::frequency > \fBinverse_time_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::mass > \fBmass_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::plane_angle > \fBangle_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::temperature > \fBtemperature_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::velocity > \fBvelocity_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::acceleration > \fBacceleration_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::mass_density > \fBdensity_type\fP"
.br
.ti -1c
.RI "typedef boost::units::quantity
.br
< boost::units::si::surface_density > \fBsurface_density_type\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum { \fBforward_tag\fP =  false, \fBreverse_tag\fP =  true }"
.br
.ti -1c
.RI "enum \fBerror_behavior_type\fP "
.br
.RI "\fIError behavior enum\&. \fP"
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBflt_type\fP \fBmagnification_alpha\fP (const \fBflt_type\fP &\fBm\fP, const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> \fBint_type\fP \fBcall_program_noexcept\fP (const char *program_name, \fBint_type\fP num_retries, Args\&.\&.\&.args)"
.br
.ti -1c
.RI "\fBint_type\fP \fBcall_program_noexcept\fP (const char *program_name)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> void \fBcall_program\fP (const char *program_name, \fBint_type\fP num_retries, Args\&.\&.\&.args)"
.br
.ti -1c
.RI "std::string \fBexec\fP (const char *cmd)"
.br
.ti -1c
.RI "template<typename To > To \fBget_cline_arg\fP (const int &argc, const char *argv[], const int &i)"
.br
.ti -1c
.RI "template<typename To > To \fBget_cline_arg\fP (const int &argc, const char *argv[], const int &i, const std::function< bool(const To &)> &test)"
.br
.ti -1c
.RI "template<typename To > To \fBget_cline_arg\fP (const int &argc, const char *argv[], const int &i, const To &default_out)"
.br
.ti -1c
.RI "template<typename To > To \fBget_cline_arg\fP (const int &argc, const char *argv[], const int &i, const std::function< bool(const To &)> &test, const To &default_out)"
.br
.ti -1c
.RI "template<typename To , typename\&.\&.\&. Tos> To \fBget_cline_arg\fP (const int &argc, const char *argv[], const int &i, const std::function< bool(const To &)> &test, const To &primary_default_out, const To &secondary_default_out, Tos\&.\&.\&.other_default_outs)"
.br
.ti -1c
.RI "template<typename NewType , int_type d = 1, typename OldType  = NewType> NewType \fBcoerce\fP (const OldType &old)"
.br
.ti -1c
.RI "template<typename NewType , int_type d = 1, typename OldType  = NewType> NewType \fBrange_coerce\fP (const OldType &old)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_CONTAINER(T) > auto \fBget\fP (T &v, const \fBint_type\fP &i)-> \fBdecltype\fP(v[i])"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_CONTAINER(T) > void \fBfix_min_and_max\fP (T &v1, T &v2)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_NULL(T) > void \fBfix_min_and_max\fP (const T &v1, const T &v2)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_CONTAINER(T) > void \fBfix_step_sigmas\fP (T &v_sigmas, const T &v_min, const T &v_max)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_NULL(T) > void \fBfix_step_sigmas\fP (const T &v_sigmas, const T &v_min, const T &v_max)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_CONTAINER(T) > void \fBfix_step_sigmas\fP (const T &v_sigmas)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_TUPLE(T) > void \fBfix_step_sigmas\fP (T &v_sigmas)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_CONTAINER(T) > auto \fBattempt_get\fP (T &v, const \fBint_type\fP &i)-> \fBdecltype\fP(v[i])"
.br
.ti -1c
.RI "\fBstatic_assert\fP (\fBis_boost_tuple\fP< boost::tuple< double, double >>::value,'ERROR: \fBis_boost_tuple\fP isn't working for tuples\&.')"
.br
.ti -1c
.RI "\fBstatic_assert\fP (\fBis_boost_tuple\fP< boost::tuple< double, double > & >::value,'ERROR: \fBis_boost_tuple\fP isn't working for tuple references\&.')"
.br
.ti -1c
.RI "\fBstatic_assert\fP (\fBis_boost_tuple\fP< boost::tuples::cons< double, boost::tuples::null_type >>::value,'ERROR: \fBis_boost_tuple\fP isn't cons lists\&.')"
.br
.ti -1c
.RI "\fBstatic_assert\fP (\fBis_boost_tuple\fP< boost::tuples::cons< double, boost::tuples::null_type > & >::value,'ERROR: \fBis_boost_tuple\fP isn't cons list references\&.')"
.br
.ti -1c
.RI "template<typename f > void \fBunary_for_each\fP (const f &func, const boost::tuples::null_type &)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt > void \fBunary_for_each\fP (const f &func, const boost::tuples::cons< Th, Tt > &t1)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt > void \fBunary_for_each\fP (const f &func, boost::tuples::cons< Th, Tt > &t1)"
.br
.ti -1c
.RI "template<typename f > void \fBbinary_for_each\fP (const f &func, const boost::tuples::null_type &, const boost::tuples::null_type &)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 > void \fBbinary_for_each\fP (const f &func, const boost::tuples::cons< Th, Tt > &t1, T2 &&t2)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 > void \fBbinary_for_each\fP (const f &func, boost::tuples::cons< Th, Tt > &t1, T2 &&t2)"
.br
.ti -1c
.RI "template<typename f > void \fBtrinary_for_each\fP (const f &func, const boost::tuples::null_type &, const boost::tuples::null_type &)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 , typename T3 > void \fBtrinary_for_each\fP (const f &func, const boost::tuples::cons< Th, Tt > &t1, T2 &&t2, T3 &&t3)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 , typename T3 > void \fBtrinary_for_each\fP (const f &func, boost::tuples::cons< Th, Tt > &t1, T2 &&t2, T3 &&t3)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBadd\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::add_typeof_helper\fP< T1, 
.br
T2 >::type \fBadd\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBsubtract\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::subtract_typeof_helper\fP
.br
< T1, T2 >::type \fBsubtract\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBmultiply\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::multiply_typeof_helper\fP
.br
< T1, T2 >::type \fBmultiply\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBdivide\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::divide_typeof_helper\fP
.br
< T1, T2 >::type \fBdivide\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBadd_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBadd_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBsubtract_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBsubtract_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBmultiply_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBmultiply_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBdivide_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBdivide_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBabs\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBsqrt\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBpow\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBruntime_ipow\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 \fBruntime_ipow\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<int_type p> boost::tuples::null_type \fBipow\fP (const boost::tuples::null_type &t1)"
.br
.ti -1c
.RI "template<int_type p, class T1 , BRG_F_IS_TUPLE(T1) > \fBtuples::ipow_typeof_helper\fP< p, 
.br
T1 >::type \fBipow\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBsin\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBcos\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBtan\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBasin\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBacos\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBatan\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBmin\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBmax\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<typename f , typename T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBrand_container\fP (const f func, const T1 &v1)"
.br
.ti -1c
.RI "template<typename f , typename T1 , typename T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBrand_container\fP (const f func, const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T , typename f , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > boost::tuples::null_type \fBrand_container_of_size\fP (const f func, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > boost::tuples::null_type \fBrand_container_of_size\fP (const f func, const T1 &v1, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_TUPLE(Tout) , BRG_F_IS_TUPLE(T1) > Tout \fBrand_container_of_size\fP (const f func, const T1 &v1, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename T2 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > boost::tuples::null_type \fBrand_container_of_size\fP (const f func, const T1 &v1, const T2 &v2, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename T2 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_TUPLE(Tout) , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > Tout \fBrand_container_of_size\fP (const f func, const T1 &v1, const T2 &v2, const \fBint_type\fP &)"
.br
.ti -1c
.RI "void \fBhandle_error\fP (const std::string &str)"
.br
.RI "\fIHandle an error message\&. \fP"
.ti -1c
.RI "void \fBhandle_notification\fP (const std::string &str)"
.br
.RI "\fIHandle a notification\&. \fP"
.ti -1c
.RI "void \fBhandle_error_message\fP (const std::string &str)"
.br
.RI "\fIHandle an error message when throwing isn't an option\&. \fP"
.ti -1c
.RI "template<typename T > void \fBprint_table\fP (std::ostream &out_stream, const table_t< T > &data, const \fBheader_t\fP &header=\fBheader_t\fP(), const char major_tag=Eigen::ColMajor, const char precision=10)"
.br
.ti -1c
.RI "template<typename T > void \fBprint_table\fP (const std::string &file_name, const table_t< T > &data, const \fBheader_t\fP &header=\fBheader_t\fP(), const char major_tag=Eigen::ColMajor)"
.br
.ti -1c
.RI "template<typename T > table_t< T > \fBload_table\fP (std::istream &fi, const char major_tag=Eigen::ColMajor, const T &default_value=T(), size_t min_length=0)"
.br
.ti -1c
.RI "template<typename T > table_t< T > \fBload_table\fP (const std::string &file_name, const char major_tag=Eigen::ColMajor, const T &default_value=T())"
.br
.ti -1c
.RI "\fBheader_t\fP \fBload_header\fP (std::istream &table_stream)"
.br
.ti -1c
.RI "\fBheader_t\fP \fBload_header\fP (const std::string &file_name)"
.br
.ti -1c
.RI "template<typename T > void \fBprint_table_map\fP (std::ostream &out, const table_map_t< T > &table_map)"
.br
.ti -1c
.RI "template<typename T > void \fBprint_table_map\fP (const std::string &file_name, const table_map_t< T > &table_map)"
.br
.ti -1c
.RI "template<typename T > table_map_t< T > \fBload_table_map\fP (std::istream &fi, const T default_value=T())"
.br
.ti -1c
.RI "template<typename T > table_map_t< T > \fBload_table_map\fP (const std::string &file_name, const T default_value=T())"
.br
.ti -1c
.RI "template<typename T > void \fBload_table_columns\fP (std::istream &fi, std::map< std::string, std::vector< T > * > &column_map, const bool case_sensitive=false, const T default_value=T())"
.br
.ti -1c
.RI "template<typename T > void \fBload_table_columns\fP (const std::string &file_name, std::map< std::string, std::vector< T > * > &column_map, const bool case_sensitive=false, const T default_value=T())"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0> void \fBbinary_save\fP (boost::archive::binary_oarchive &ar, const T &obj)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< std::is_same< typename T::value_type, bool >::value, char >::type  = 0> void \fBbinary_save\fP (boost::archive::binary_oarchive &ar, const T &obj)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!std::is_same< typename T::value_type, bool >::value, char >::type  = 0> void \fBbinary_save\fP (boost::archive::binary_oarchive &ar, const std::vector< T > &obj)"
.br
.ti -1c
.RI "template<typename T > void \fBbinary_save\fP (std::ostream &out, const T &obj)"
.br
.ti -1c
.RI "template<typename T > void \fBbinary_save\fP (const std::string &filename, const T &obj)"
.br
.ti -1c
.RI "template<typename T , typename T_test  = T, typename std::enable_if<!IceBRG::is_stl_container< T_test >::value, char >::type  = 0> T \fBbinary_load\fP (boost::archive::binary_iarchive &ar)"
.br
.ti -1c
.RI "template<typename T , typename T_test  = T, typename std::enable_if< IceBRG::is_stl_container< T_test >::value, char >::type  = 0, typename std::enable_if< std::is_same< typename T_test::value_type, bool >::value, char >::type  = 0> T \fBbinary_load\fP (boost::archive::binary_iarchive &ar)"
.br
.ti -1c
.RI "template<typename T > T \fBbinary_load\fP (std::istream &in)"
.br
.ti -1c
.RI "template<typename T > T \fBbinary_load\fP (const std::string &filename)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_file\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_file_input\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_file_output\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_file_io\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_file_append\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_bin_file\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "void \fBopen_bin_file\fP (std::fstream &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_bin_file_input\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_bin_file_io\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_bin_file_output\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename stream_type > void \fBopen_bin_file_append\fP (stream_type &stream, const std::string &name)"
.br
.ti -1c
.RI "template<typename T , typename T_data  = typename T::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr> void \fBprint_pixels\fP (std::ostream &out_stream, const T &data)"
.br
.ti -1c
.RI "template<typename T , typename T_data  = typename T::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr> void \fBprint_pixels\fP (const std::string &file_name, const T &data)"
.br
.ti -1c
.RI "template<typename T , typename T_data  = typename T::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr> void \fBprint_pixels\fP (std::ostream &out_stream, const T &data)"
.br
.ti -1c
.RI "template<typename T , typename T_data  = typename T::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr> void \fBprint_pixels\fP (const std::string &file_name, const T &data)"
.br
.ti -1c
.RI "template<typename T , typename T_data  = typename T::value_type::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type::value_type >::value, typename T::value_type::value_type::value_type >::type *  = nullptr> void \fBprint_pixels\fP (std::ostream &out_stream, const T &data)"
.br
.ti -1c
.RI "template<typename T , typename T_data  = typename T::value_type::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type::value_type >::value, typename T::value_type::value_type::value_type >::type *  = nullptr> void \fBprint_pixels\fP (const std::string &file_name, const T &data)"
.br
.ti -1c
.RI "template<typename T > table_map_t< T > \fBmake_table_map\fP (const table_t< T > &data, const \fBheader_t\fP &header)"
.br
.ti -1c
.RI "std::vector< std::string > \fBsplit_on_whitespace\fP (const std::string &sentence)"
.br
.ti -1c
.RI "\fBheader_t\fP \fBconvert_to_header\fP (const std::string &line)"
.br
.ti -1c
.RI "template<typename T_out , typename T_in , typename std::enable_if< std::is_same< T_out, std::string >::value, char >::type  = 0> T_in & \fBpop_from_istream\fP (T_in &in, T_out &out)"
.br
.ti -1c
.RI "template<typename T_out , typename T_in > std::vector< T_out > \fBsplit_line\fP (T_in &&line_data, const T_out &default_value=T_out(), const size_t &min_length=0)"
.br
.ti -1c
.RI "template<typename streamtype > void \fBtrim_comments_one_line\fP (streamtype &stream)"
.br
.ti -1c
.RI "template<typename streamtype > void \fBtrim_comments_all_at_top\fP (streamtype &stream)"
.br
.ti -1c
.RI "void \fBreduce_slashes\fP (std::string &\fBs\fP)"
.br
.ti -1c
.RI "std::string \fBjoin_strings\fP (const std::string &s1, const std::string &s2)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. To> std::string \fBjoin_strings\fP (const std::string &s1, const std::string &s2, const std::string &s3, To\&.\&.\&.so)"
.br
.ti -1c
.RI "std::string \fBjoin_path\fP (const std::string &s1, const std::string &s2)"
.br
.ti -1c
.RI "template<typename\&.\&.\&. To> std::string \fBjoin_path\fP (const std::string &s1, const std::string &s2, const std::string &s3, To\&.\&.\&.so)"
.br
.ti -1c
.RI "bool \fBbool_cast\fP (const std::string &\fBs\fP)"
.br
.ti -1c
.RI "template<typename T_o , typename T_i > T_o \fBmin_cast\fP (const T_i &\fBs\fP)"
.br
.ti -1c
.RI "template<typename T_o , typename T_i > T_o \fBmax_cast\fP (const T_i &\fBs\fP)"
.br
.ti -1c
.RI "template<typename f , typename Td  = flt_type, typename Tv  = flt_type, typename Tt  = flt_type> const \fBint_type\fP \fBleapfrog_step\fP (const Td &x, const Td &y, const Td &z, const Tv &vx, const Tv &vy, const Tv &vz, Td &new_x, Td &new_y, Td &new_z, Tv &new_vx, Tv &new_vy, Tv &new_vz, const Tt &t_step, const f *accel_func)"
.br
.ti -1c
.RI "template<typename f , typename Td  = flt_type, typename Tv  = flt_type, typename Tt  = flt_type> const \fBint_type\fP \fBleapfrog_step\fP (Td &x, Td &y, Td &z, Tv &vx, Tv &vy, Tv &vz, const Tt &t_step, const f *accel_func)"
.br
.ti -1c
.RI "template<typename f , typename Tp , typename Tt  = flt_type> const \fBint_type\fP \fBleapfrog_step\fP (const Tp &p, Tp &new_p, const Tt &t_step, const f *accel_func)"
.br
.ti -1c
.RI "template<typename f , typename Tp , typename Tt  = flt_type> const \fBint_type\fP \fBleapfrog_step\fP (Tp &p, const Tt &t_step, const f *accel_func)"
.br
.ti -1c
.RI "template<typename f , typename T > T \fBdifferentiate\fP (const f *func, const T &in_param, const \fBint_type\fP order=1, const \fBflt_type\fP &power=1, const T &factor=\fBSMALL_FACTOR\fP)"
.br
.ti -1c
.RI "template<typename f , typename T > std::vector< std::vector< T > > \fBdifferentiate\fP (const f *func, const std::vector< T > &in_params, const \fBint_type\fP order=1, const \fBflt_type\fP &power=1)"
.br
.ti -1c
.RI "template<typename f , typename T > auto \fBintegrate_trapezoid\fP (const f *func, const T &min_in_param, const T &max_in_param, const T &in_param_step)-> \fBdecltype\fP(func(min_in_param)*min_in_param)"
.br
.ti -1c
.RI "template<typename f , typename T > auto \fBintegrate_trapezoid\fP (const f *func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const std::vector< T > &in_param_step, const std::vector< T > &passed_in_param=std::vector< T >(0))-> \fBdecltype\fP(\fBmultiply\fP(func(min_in_param)"
.br
.ti -1c
.RI "T auto \fBintegrate_trapezoid\fP (const f *func, const T &min_in_param, const T &max_in_param, const \fBint_type\fP num_samples)-> \fBdecltype\fP(func(min_in_param)*min_in_param)"
.br
.ti -1c
.RI "template<typename f , typename T > auto \fBintegrate_trapezoid\fP (const f *func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBint_type\fP num_samples, const std::vector< T > &passed_in_param=std::vector< T >(0))-> \fBdecltype\fP(func(min_in_param))"
.br
.ti -1c
.RI "template<typename f1 , typename f2 , typename T > auto \fBintegrate_weighted_trapezoid\fP (const f1 *func, const f2 *func_weight, const T &min_in_param, const T &max_in_param, const T &in_param_step)-> \fBdecltype\fP(func(min_in_param))"
.br
.ti -1c
.RI "template<typename f1 , typename f2 , typename T > auto \fBintegrate_weighted_trapezoid\fP (const f1 *func, const f2 *func_weight, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const std::vector< T > &in_param_step, const std::vector< T > &passed_in_param=std::vector< T >(0))-> \fBdecltype\fP(func(min_in_param))"
.br
.ti -1c
.RI "template<typename f1 , typename f2 , typename T > auto \fBintegrate_weighted_trapezoid\fP (const f1 *func, const f2 *func_weight, const T &min_in_param, const T &max_in_param, const \fBint_type\fP num_samples)-> \fBdecltype\fP(func(min_in_param))"
.br
.ti -1c
.RI "template<typename f1 , typename f2 , typename T > auto \fBintegrate_weighted_trapezoid\fP (const f1 *func, const f2 *func_weight, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBint_type\fP num_samples, const std::vector< T > &passed_in_param=std::vector< T >(0))-> \fBdecltype\fP(func(min_in_param))"
.br
.ti -1c
.RI "template<typename f , typename T > auto \fBintegrate_mc\fP (const f *func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBint_type\fP num_samples)-> \fBdecltype\fP(\fBmultiply\fP(func(min_in_param)"
.br
.ti -1c
.RI "Tin auto \fBintegrate_Romberg\fP (const f &func, const Tin &min_in_param, const Tin &max_in_param, \fBflt_type\fP precision=0\&.00001, bool tighten_precision=false)-> \fBdecltype\fP(func(min_in_param)*min_in_param)"
.br
.ti -1c
.RI "template<typename f , typename T > auto \fBintegrate_Romberg\fP (const f &func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBflt_type\fP &precision=0\&.00001, const bool tighten_precision=false, const std::vector< T > &passed_in_param=std::vector< T >(0))-> \fBdecltype\fP(\fBmultiply\fP(func(min_in_param)"
.br
.ti -1c
.RI "T auto \fBintegrate_product_Romberg\fP (const f_in_1 &func1, const \fBf_in_2\fP &\fBfunc2\fP, const T &min_in_param, const T &max_in_param, const \fBflt_type\fP &precision=0\&.00001, const bool tighten_precision=false)-> \fBdecltype\fP(func1(min_in_param)*\fBfunc2\fP(min_in_param)*min_in_param)"
.br
.ti -1c
.RI "template<typename f_in_1 , typename f_in_2 , typename T > auto \fBintegrate_product_Romberg\fP (const f_in_1 &func1, const \fBf_in_2\fP &\fBfunc2\fP, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBflt_type\fP &precision=0\&.00001, const bool tighten_precision=false, const std::vector< T > &passed_in_param=std::vector< T >(0))-> \fBdecltype\fP(\fBmultiply\fP(\fBmultiply\fP(func1(min_in_param)"
.br
.ti -1c
.RI "auto \fBfunc2\fP (min_in_param))"
.br
.ti -1c
.RI "T auto \fBintegrate_weighted_Romberg\fP (const f_in_1 &func, const \fBf_in_2\fP &func_weight, const T &min_in_param, const T &max_in_param, const \fBflt_type\fP &precision=0\&.00001, const bool tighten_precision=false)-> \fBdecltype\fP(func(min_in_param))"
.br
.ti -1c
.RI "template<typename f_in_1 , typename f_in_2 , typename T > auto \fBintegrate_weighted_Romberg\fP (const f_in_1 &func, const \fBf_in_2\fP &func_weight, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBflt_type\fP &precision=0\&.00001, const bool tighten_precision=false, const std::vector< T > &passed_in_param=std::vector< T >(0))-> \fBdecltype\fP(func(min_in_param))"
.br
.ti -1c
.RI "bool \fBp1first_lt_p2first\fP (std::pair< \fBflt_type\fP, \fBflt_type\fP > pair1, std::pair< \fBflt_type\fP, \fBflt_type\fP > pair2)"
.br
.ti -1c
.RI "bool \fBp1first_lt_v2\fP (std::pair< \fBflt_type\fP, \fBflt_type\fP > pair1, \fBflt_type\fP v2)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, T >::type *  = nullptr> T \fB_runtime_ipow\fP (T v, \fBint_type\fP p)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, T >::type *  = nullptr> T \fBruntime_ipow\fP (T v, \fBint_type\fP p)"
.br
.ti -1c
.RI "template<int_type p> \fBflt_type\fP \fBipow\fP (const \fBflt_type\fP &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< std::numeric_limits< T >::has_quiet_NaN, T >::type *  = nullptr> bool \fBisnan\fP (const T &val)"
.br
.ti -1c
.RI "bool \fBisnan\fP (const std::string &val)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< std::numeric_limits< T >::has_infinity, T >::type *  = nullptr> bool \fBisinf\fP (T val)"
.br
.ti -1c
.RI "bool \fBisinf\fP (const std::string &val)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< !std::numeric_limits< T >::has_infinity, T >::type *  = nullptr> bool \fBisinf\fP (const T &val)"
.br
.ti -1c
.RI "template<typename T > bool \fBisbad\fP (const T &val)"
.br
.ti -1c
.RI "bool \fBisbad\fP (std::string &val)"
.br
.ti -1c
.RI "template<typename T > bool \fBisgood\fP (const T &val)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!boost::units::is_quantity< T >::value, char >::type  = 0> void \fBfixbad\fP (T &val)"
.br
.ti -1c
.RI "template<class T1 , class T2 , class T3 , BRG_F_NOT_CONTAINER(T1) , BRG_F_NOT_CONTAINER(T2) , BRG_F_NOT_CONTAINER(T3) > T2 \fBbound\fP (T1 &&lower_bound, T2 &&a, T3 &&upper_bound)"
.br
.ti -1c
.RI "template<class T > T & \fBmin_ref\fP (T &a, T &b)"
.br
.ti -1c
.RI "template<class T > T & \fBmax_ref\fP (T &a, T &b)"
.br
.ti -1c
.RI "template<typename Ta , typename Tb > bool \fBdivisible\fP (const Ta &a, const Tb &b)"
.br
.ti -1c
.RI "\fBint_type\fP \fBround_int\fP (\fBflt_type\fP value, const \fBflt_type\fP &epsilon=std::numeric_limits< \fBflt_type\fP >::epsilon())"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > \fBdecltype\fP (T()*T()) \fBsquare\fP(const T &v1)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > \fBdecltype\fP (T()*\fBsquare\fP(T())) \fBcube\fP(const T &v1)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > \fBdecltype\fP (\fBsquare\fP(T())*\fBsquare\fP(T())) \fBquart\fP(const T &v1)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > \fBdecltype\fP (1/T()) \fBinverse\fP(const T &v1)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > \fBdecltype\fP (\fBinverse\fP(\fBsquare\fP(T()))) \fBinv_square\fP(const T &v1)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > \fBdecltype\fP (\fBinverse\fP(\fBcube\fP(T()))) \fBinv_cube\fP(const T &v1)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > \fBdecltype\fP (\fBinverse\fP(\fBquart\fP(T()))) \fBinv_quart\fP(const T &v1)"
.br
.ti -1c
.RI "template<typename T , BRG_F_NOT_CONTAINER(T) > constexpr \fBshort_int_type\fP \fBsign\fP (const T &x, std::false_type is_signed)"
.br
.ti -1c
.RI "template<typename T , BRG_F_NOT_CONTAINER(T) > constexpr \fBshort_int_type\fP \fBsign\fP (const T &x, std::true_type is_signed)"
.br
.ti -1c
.RI "template<typename T , BRG_F_NOT_CONTAINER(T) > constexpr \fBshort_int_type\fP \fBsign\fP (const T &x)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) > T1 \fBquad_add\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename T3 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) , BRG_F_IS_EIGEN_OR_SCALAR(T3) > T1 \fBquad_add\fP (const T1 &v1, const T2 &v2, const T3 v3)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) > T1 \fBquad_sub\fP (const T1 &v1, const T2 v2)"
.br
.ti -1c
.RI "template<typename Tx1 , typename Ty1 , typename Tx2 , typename Ty2 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tx2) , BRG_F_IS_EIGEN_OR_SCALAR(Ty2) > Tx1 \fBdist2d\fP (const Tx1 &x1, const Ty1 &y1, const Tx2 &x2, const Ty2 &y2)"
.br
.ti -1c
.RI "template<typename Tx1 , typename Ty1 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) > Tx1 \fBdist2d\fP (const Tx1 &x1, const Ty1 &y1)"
.br
.ti -1c
.RI "template<typename Tx1 , typename Ty1 , typename Ta1 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Ta1) > Tx1 \fBlc_add\fP (const Tx1 &x1, const Ty1 &y1, const Ta1 &a1)"
.br
.ti -1c
.RI "template<typename Tx1 , typename Ty1 , typename Tz1 , typename Tx2 , typename Ty2 , typename Tz2 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tz1) , BRG_F_IS_EIGEN_OR_SCALAR(Tx2) , BRG_F_IS_EIGEN_OR_SCALAR(Ty2) , BRG_F_IS_EIGEN_OR_SCALAR(Tz2) > Tx1 \fBdist3d\fP (const Tx1 &x1, const Ty1 &y1, const Tz1 &z1, const Tx2 &x2, const Ty2 &y2, const Tz2 &z2)"
.br
.ti -1c
.RI "template<typename Tx1 , typename Ty1 , typename Tz1 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tz1) > Tx1 \fBdist3d\fP (const Tx1 &x1, const Ty1 &y1, const Tz1 &z1)"
.br
.ti -1c
.RI "template<typename Ta , typename Tb , BRG_F_NOT_CONTAINER(Ta) , BRG_F_NOT_CONTAINER(Tb) > Ta \fBweighted_dist\fP (const std::vector< Ta > &a, const std::vector< Tb > &b)"
.br
.ti -1c
.RI "template<typename Ta , typename Tb , typename Tc , BRG_F_NOT_CONTAINER(Ta) , BRG_F_NOT_CONTAINER(Tb) , BRG_F_NOT_CONTAINER(Tc) > Ta \fBweighted_dist\fP (const std::vector< Ta > &a, const std::vector< Tb > &b, const std::vector< Tc > &\fBc\fP)"
.br
.ti -1c
.RI "template<typename Tx1 , typename Ty1 , typename Tz1 , typename Tx2 , typename Ty2 , typename Tz2 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tz1) , BRG_F_IS_EIGEN_OR_SCALAR(Tx2) , BRG_F_IS_EIGEN_OR_SCALAR(Ty2) , BRG_F_IS_EIGEN_OR_SCALAR(Tz2) > Tx1 \fBdot_product\fP (const Tx1 &x1, const Ty1 &y1, const Tz1 &z1, const Tx2 &x2, const Ty2 &y2, const Tz2 &z2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NOT_CONTAINER(T1) , BRG_F_NOT_CONTAINER(T2) > T1 \fBdot_product\fP (const std::vector< T1 > &a, const std::vector< T2 > &b)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) > T1 \fBquad_add_err\fP (const T1 &v1, const T1 &v1_err, const T2 &v2, const T2 &v2_err)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename T3 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) , BRG_F_IS_EIGEN_OR_SCALAR(T3) > T1 \fBquad_add_err\fP (const T1 &v1, const T1 &v1_err, const T2 &v2, const T2 &v2_err, const T3 &v3, const T3 &v3_err)"
.br
.ti -1c
.RI "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 \fBsquare_err\fP (T1 v, T1 v_err)"
.br
.ti -1c
.RI "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 \fBsqrt_err\fP (const T1 &v, T1 v_err)"
.br
.ti -1c
.RI "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 \fBpow_err\fP (const T1 &v, T1 v_err, const \fBlong_flt_type\fP &p)"
.br
.ti -1c
.RI "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 \fBipow_err\fP (const T1 &v, T1 v_err, \fBint_type\fP p)"
.br
.ti -1c
.RI "template<typename Tx > Tx \fBerf\fP (Tx &&x)"
.br
.ti -1c
.RI "template<typename Tx > Tx \fBerfc\fP (Tx &&x)"
.br
.ti -1c
.RI "template<typename Tx , typename Tmean , typename Tstddev > \fBflt_type\fP \fBGaus_pdf\fP (const Tx x, const Tmean \fBmean\fP, const Tstddev std_dev)"
.br
.ti -1c
.RI "template<typename Tx , typename Tmean > \fBflt_type\fP \fBGaus_pdf\fP (const Tx x, const Tmean \fBmean\fP)"
.br
.ti -1c
.RI "template<typename Tx > \fBflt_type\fP \fBGaus_pdf\fP (const Tx x)"
.br
.ti -1c
.RI "template<typename Tr , typename Tstddev > \fBflt_type\fP \fBspherical_Gaus_pdf\fP (const Tr &r, const Tstddev &\fBstddev\fP)"
.br
.ti -1c
.RI "template<typename Tr > \fBflt_type\fP \fBspherical_Gaus_pdf\fP (const Tr &r)"
.br
.ti -1c
.RI "template<typename Tlo , typename Thi , typename Tmean , typename Tstddev > \fBflt_type\fP \fBGaus_int\fP (const Tlo \fBmin\fP, const Thi \fBmax\fP)"
.br
.ti -1c
.RI "template<typename Tlo , typename Thi , typename Tmean > \fBflt_type\fP \fBGaus_int\fP (const Tlo \fBmin\fP, const Thi \fBmax\fP, const Tmean \fBmean\fP)"
.br
.ti -1c
.RI "template<typename Tlo , typename Thi , typename Tmean , typename Tstddev > \fBflt_type\fP \fBGaus_int\fP (const Tlo \fBmin\fP, const Thi \fBmax\fP, const Tmean \fBmean\fP, const Tstddev std_dev)"
.br
.ti -1c
.RI "template<typename T  = int_type, typename T_in  = int_type, typename T_gen  = decltype(rng)> T \fBirand\fP (T_in &&\fBmin\fP, T_in &&\fBmax\fP, T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T \fBdrand\fP (T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T \fBdrand\fP (T_in &&\fBmin\fP, T_in &&\fBmax\fP, T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T \fBGaus_rand\fP (T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T \fBGaus_rand\fP (T_in &&\fBmean\fP, T_in &&\fBstddev\fP=1\&.0, T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T \fBlog10Gaus_rand\fP (T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T \fBlog10Gaus_rand\fP (T_in &&\fBmean\fP, T_in &&\fBstddev\fP=1\&., T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T \fBRayleigh_rand\fP (T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T \fBRayleigh_rand\fP (T_in &&sigma, T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = int_type, typename T_gen  = decltype(rng)> T \fBPois_rand\fP (T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T  = int_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T \fBPois_rand\fP (T_in &&lambda=1\&., T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<class T > const T \fBsafe_sqrt\fP (const T &a)"
.br
.ti -1c
.RI "\fBflt_type\fP \fBsafe_sqrt\fP (const \fBint_type\fP a)"
.br
.ti -1c
.RI "template<class Ta > const Ta \fBsafe_pow\fP (const Ta &a, const \fBflt_type\fP &x)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > const T1 \fBsafe_quad_sub\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<class T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!IceBRG::is_eigen_container< T >::value, char >::type  = 0, typename std::enable_if<!boost::units::is_quantity< T >::value, char >::type  = 0> const T \fBsafe_d\fP (const T &a)"
.br
.ti -1c
.RI "template<class T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T \fBsafe_d\fP (T array)"
.br
.ti -1c
.RI "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > const T \fBsolve_iterate\fP (const f &func, const T &init_param=0, const \fBint_type\fP slowdown=1, const \fBflt_type\fP &precision=0\&.0001, const \fBint_type\fP max_counter=10000)"
.br
.ti -1c
.RI "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > T \fBsolve_sd\fP (const f &func, const T &init_in_params, const \fBflt_type\fP &precision=0\&.00001, const \fBflt_type\fP &lambda=0\&.1, const \fBflt_type\fP &cusp_override_power=0, const \fBint_type\fP max_steps=10000)"
.br
.ti -1c
.RI "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > std::vector< T > \fBsolve_sd\fP (const f &func, const std::vector< T > &init_in_params, const \fBflt_type\fP &precision=0\&.00001, const \fBflt_type\fP &lambda=0\&.1, const \fBflt_type\fP &cusp_override_power=0, const \fBint_type\fP max_steps=10000)"
.br
.ti -1c
.RI "template<typename f , typename Tin , typename Tout , BRG_F_NOT_CONTAINER(Tin) , BRG_F_NOT_CONTAINER(Tout) > Tin \fBsolve_grid\fP (const f &func, const Tin &init_min_in_param, const Tin &init_max_in_param, const Tin &init_init_in_params_step, const Tout &target_out_param, const \fBflt_type\fP &init_init_precision=0\&.00001, const \fBflt_type\fP &search_precision=0\&.1)"
.br
.ti -1c
.RI "template<typename f , typename Tin , BRG_F_NOT_CONTAINER(Tin) > std::vector< Tin > \fBsolve_grid\fP (const f &func, const std::vector< Tin > &init_min_in_params, const std::vector< Tin > &init_max_in_params, const std::vector< Tin > &init_init_in_params_step, const \fBdecltype\fP(f()(std::vector< Tin >()))&target_out_params=\fBdecltype\fP(f()(std::vector< Tin >()))(), const \fBflt_type\fP &init_init_precision=0\&.00001, const \fBflt_type\fP &search_precision=0\&.1, const std::vector< \fBflt_type\fP > &init_out_params_weight=std::vector< \fBflt_type\fP >(0))"
.br
.ti -1c
.RI "template<typename f , typename Tin , typename Tout , BRG_F_NOT_CONTAINER(Tin) , BRG_F_NOT_CONTAINER(Tout) > Tin \fBsolve_grid\fP (const f &func, const Tin &init_min_in_params, const Tin &init_max_in_params, const \fBint_type\fP &num_search_steps, const Tout &target_out_params, const \fBflt_type\fP &init_init_precision=0\&.00001, const \fBflt_type\fP &search_precision=0\&.1)"
.br
.ti -1c
.RI "template<typename f , typename Tin , typename Tout , BRG_F_NOT_CONTAINER(Tin) , BRG_F_NOT_CONTAINER(Tout) > std::vector< Tin > \fBsolve_grid\fP (const f &func, const std::vector< Tin > &init_min_in_params, const std::vector< Tin > &init_max_in_params, const \fBint_type\fP &num_search_steps, const std::vector< Tout > &target_out_params, const \fBflt_type\fP &init_init_precision=0\&.00001, const \fBflt_type\fP &search_precision=0\&.1, const std::vector< \fBflt_type\fP > &out_params_weight=std::vector< \fBflt_type\fP >(0))"
.br
.ti -1c
.RI "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > T \fBsolve_MCMC\fP (const f &func, const T &init_in_param, const T &init_min_in_param, const T &init_max_in_param, const T &init_in_param_step_sigma, const \fBint_type\fP &max_steps=1000000, const \fBint_type\fP &annealing_period=100000, const \fBflt_type\fP &annealing_factor=4)"
.br
.ti -1c
.RI "template<typename T_vec , typename T_gen  = decltype(rng)> T_vec \fBget_case_resampled\fP (const T_vec &vec, T_gen &gen=\fBrng\fP)"
.br
.ti -1c
.RI "template<typename T_vec , std::enable_if< IceBRG::is_eigen_container< T_vec >::value, char >  = 0> T_vec \fBget_jackknife_resampled\fP (const T_vec &vec, const \fBint_type\fP &sample_num=0, const \fBint_type\fP &num_samples=2)"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_count\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_count\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_effective_count\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_effective_count\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_sum_of_weights\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_sum_of_weights\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_mean_weight\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_mean_weight\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_sum_of_square_weights\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_sum_of_square_weights\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_sum\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_sum\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_weighted_sum\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_weighted_sum\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_weighted_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_weighted_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_error_of_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_error_of_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_error_of_weighted_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_error_of_weighted_mean\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_variance\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_variance\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBextract_weighted_variance\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename Ti > auto \fBsafe_extract_weighted_variance\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<int_type n, typename Ti > auto \fBextract_moment\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<int_type n, typename Ti > auto \fBsafe_extract_moment\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<int_type n, typename Ti > auto \fBextract_weighted_moment\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<int_type n, typename Ti > auto \fBsafe_extract_weighted_moment\fP (Ti &&acc)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "table_map_t< \fBflt_type\fP > \fBget_table_after_unitconv\fP (table_map_t< \fBflt_type\fP > data_map, const \fBunitconv_map\fP &u_map)"
.br
.ti -1c
.RI "template<typename T > table_map_t< \fBflt_type\fP > \fBget_table_after_unitconv\fP (const table_map_t< T > &data_map, const \fBunitconv_map\fP &u_map)"
.br
.ti -1c
.RI "typedef \fBdecltype\fP (\fBangle_type\fP()*\fBangle_type\fP()) square_angle_type"
.br
.ti -1c
.RI "const auto \fBmeter_per_second\fP (boost::units::si::meter/boost::units::si::second)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!std::is_same< T, any_units_type >::value &&boost::units::is_quantity< T >::value, char >::type  = 0> \fBflt_type\fP \fBvalue_of\fP (const T &x)"
.br
.ti -1c
.RI "template<typename Tstored , typename T , typename std::enable_if< std::is_same< T, any_units_type >::value, char >::type  = 0> \fBflt_type\fP \fBvalue_of\fP (const T &x)"
.br
.ti -1c
.RI "template<typename Tout , typename Tin , typename Tout_copy  = Tout, typename std::enable_if< boost::units::is_quantity< Tout_copy >::value, char >::type  = 0> Tout \fBunits_cast\fP (const Tin &x)"
.br
.ti -1c
.RI "template<typename Tout , typename Tin > \fBany_units_type\fP \fBany_units_cast\fP (const Tin &x)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> T \fBabs\fP (const T &x)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> auto \fBsqrt\fP (const T &x)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<int_type e, typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> auto \fBipow\fP (const T &x)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<int_type en, int_type ed, typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> auto \fBipow\fP (const T &x)-> \fBdecltype\fP(boost"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP \fBsin\fP (const T &x)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP \fBcos\fP (const T &x)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP \fBtan\fP (const T &x)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBangle_type\fP \fBasin\fP (const T &x)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBangle_type\fP \fBacos\fP (const T &x)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBangle_type\fP \fBatan\fP (const T &y)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBangle_type\fP \fBatan2\fP (const T &y, const T &x=1\&.)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_CONTAINER(T) > \fBint_type\fP \fBssize\fP (const T &container)"
.br
.ti -1c
.RI "void \fBset_zero\fP (\fBint_type\fP &obj)"
.br
.ti -1c
.RI "void \fBset_zero\fP (\fBshort_int_type\fP &obj)"
.br
.ti -1c
.RI "void \fBset_zero\fP (\fBlong_int_type\fP &obj)"
.br
.ti -1c
.RI "void \fBset_zero\fP (\fBflt_type\fP &obj)"
.br
.ti -1c
.RI "void \fBset_zero\fP (\fBlong_flt_type\fP &obj)"
.br
.ti -1c
.RI "template<typename T > void \fBset_zero\fP (std::vector< T > &vec)"
.br
.ti -1c
.RI "template<typename T > void \fBset_zero\fP (T *&obj)"
.br
.ti -1c
.RI "template<typename obj_type > void \fBset_zero\fP (obj_type &obj)"
.br
.ti -1c
.RI "template<typename obj_type > void \fBmake_obj\fP (\fBBRG_UNIQUE_PTR\fP< obj_type > &obj_pointer)"
.br
.ti -1c
.RI "template<typename f , typename T > T \fBapply\fP (const f &func, T v1)"
.br
.ti -1c
.RI "template<typename f , typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1 \fBapply\fP (const f &func, T1 v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename f , typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T2 \fBapply\fP (const f &func, const T1 &v1, T2 v2)"
.br
.ti -1c
.RI "template<typename f , typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 \fBapply\fP (const f &func, const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename f , typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > auto \fBrand_container\fP (const f func, const T1 &v1, const T2 &v2)-> \fBstd\fP"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto \fBadd\fP (const T1 &v1, const T2 &v2)-> \fBdecltype\fP(v1+v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto \fBsubtract\fP (const T1 &v1, const T2 &v2)-> \fBdecltype\fP(v1-v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto \fBmultiply\fP (const T1 &v1, const T2 &v2)-> \fBdecltype\fP(v1 *v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto \fBdivide\fP (const T1 &v1, const T2 &v2)-> \fBdecltype\fP(v1/v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 \fBpow\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 \fBpow\fP (T1 v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_SECOND_STL(T1, T2) > T2 \fBpow\fP (const T1 &v1, T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 \fBruntime_ipow\fP (T1 v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_SECOND_STL(T1, T2) > T1 \fBruntime_ipow\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 \fBsafe_pow\fP (T1 v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_SECOND_STL(T1, T2) > T2 \fBsafe_pow\fP (const T1 &v1, T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL_OR_EIGEN(T1) , BRG_F_IS_STL_OR_EIGEN(T2) > T1 \fBmax\fP (T1 &&v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 \fBmax\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 \fBmax\fP (T1 &&v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 \fBmax\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 \fBmax\fP (T1 &&v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NOT_CONTAINER(T1) , BRG_F_IS_STL(T2) > T2 \fBmax\fP (const T1 &v1, T2 &&v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL_OR_EIGEN(T1) , BRG_F_IS_STL_OR_EIGEN(T2) > T1 \fBmin\fP (T1 &&v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 \fBmin\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 \fBmin\fP (T1 &&v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NOT_CONTAINER(T1) , BRG_F_IS_STL(T2) > T2 \fBmin\fP (const T1 &v1, T2 &&v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename T3 , typename std::enable_if< IceBRG::is_stl_container< T1 >::value||IceBRG::is_eigen_container< T1 >::value||IceBRG::is_stl_container< T2 >::value||IceBRG::is_eigen_container< T2 >::value||IceBRG::is_stl_container< T3 >::value||IceBRG::is_eigen_container< T3 >::value, char >::type  = 0> T2 \fBbound\fP (T1 &&lower_bound, T2 &&a, T3 &&upper_bound)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBnegate\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBnegate\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBabs\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBsqrt\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBsafe_sqrt\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBexp\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBlog\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBsquare\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBcube\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBquart\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBinverse\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBinv_square\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBinv_cube\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBinv_quart\fP (T v)"
.br
.ti -1c
.RI "template<typename T , BRG_F_IS_STL(T) > T \fBsafe_d\fP (T v)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & \fBadd_equal\fP (T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1 & \fBadd_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & \fBsubtract_equal\fP (T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1 & \fBsubtract_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & \fBmultiply_equal\fP (T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1 & \fBmultiply_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & \fBdivide_equal\fP (T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1 & \fBdivide_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "const std::vector< bool > \fBv_not\fP (std::vector< bool > v)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBequal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector< bool > \fBequal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBequal\fP (const T2 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBnot_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector< bool > \fBnot_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBnot_equal\fP (const T2 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBless_than\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector< bool > \fBless_than\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBless_than\fP (const T2 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBgreater_than\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector< bool > \fBgreater_than\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBgreater_than\fP (const T2 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBless_than_or_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector< bool > \fBless_than_or_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBless_than_or_equal\fP (const T2 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBgreater_than_or_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector< bool > \fBgreater_than_or_equal\fP (const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > std::vector< bool > \fBgreater_than_or_equal\fP (const T2 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T > const T \fBv_not\fP (T v)"
.br
.ti -1c
.RI "const bool \fBv_not\fP (const bool v)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBis_monotonically_increasing\fP (const \fBIceBRG::limit_vector\fP< T, A > &v)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBabove_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBabove_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_above_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_above_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBunder_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBunder_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_under_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_under_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBoutside_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBoutside_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_outside_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_outside_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBinside_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBinside_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_inside_limits\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> bool \fBchecked_inside_limits\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP \fBchecked_get_bin_index\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP \fBchecked_get_bin_index\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP \fBget_bin_index\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP \fBget_bin_index\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP \fBget_bin_index_no_overflow\fP (const T &val, const std::vector< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP \fBget_bin_index_no_overflow\fP (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"
.br
.ti -1c
.RI "template<typename T1 , typename A1  = std::allocator<T1>, typename T2  = T1, typename A2  = std::allocator<T2>> T2 \fBinterpolate_bins\fP (const T2 &val, const std::vector< T1, A1 > &lim_vec, const std::vector< T2, A2 > &val_vec)"
.br
.ti -1c
.RI "template<typename T1 , typename A1  = std::allocator<T1>, typename T2  = T1, typename A2  = std::allocator<T2>> T2 \fBinterpolate_bins\fP (const T2 &val, const \fBIceBRG::limit_vector\fP< T1, A1 > &lim_vec, const std::vector< T2, A2 > &val_vec)"
.br
.ti -1c
.RI "template<typename T1 , typename A1  = std::allocator<T1>> std::vector< T1, A1 > \fBget_bin_mids_from_limits\fP (std::vector< T1, A1 > vec)"
.br
.ti -1c
.RI "template<typename T1 , typename A1  = std::allocator<T1>> std::vector< T1, A1 > \fBget_bin_mids_from_limits\fP (const \fBIceBRG::limit_vector\fP< T1, A1 > &vec)"
.br
.ti -1c
.RI "template<typename T1 , typename A1  = std::allocator<T1>> std::vector< T1, A1 > \fBget_bin_limits_from_mids\fP (std::vector< T1, A1 > vec)"
.br
.ti -1c
.RI "template<typename T1 , typename A1  = std::allocator<T1>> \fBIceBRG::limit_vector\fP< T1, A1 > \fBmake_limit_vector_from_mids\fP (std::vector< T1, A1 > vec)"
.br
.ti -1c
.RI "template<typename T1 , typename A1  = std::allocator<T1>> \fBIceBRG::limit_vector\fP< T1, A1 > \fBmake_limit_vector_from_mids\fP (std::vector< T1, A1 > &&vec)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> std::vector< T, A > \fBmake_linear_limit_vector_base\fP (const T &\fBmin\fP, const T &\fBmax\fP, const size_t &num_bins)"
.br
.ti -1c
.RI "template<typename T , typename A  = std::allocator<T>> std::vector< T, A > \fBmake_log_limit_vector_base\fP (const T &\fBmin\fP, const T &\fBmax\fP, const size_t &num_bins)"
.br
.ti -1c
.RI "template<typename container > void \fBmake_vector_default\fP (container &vec, const typename \fBcontainer::size_type\fP &d1)"
.br
.ti -1c
.RI "template<typename container , typename\&.\&.\&. Args> void \fBmake_vector_default\fP (container &vec, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"
.br
.ti -1c
.RI "template<int_type d, typename container , typename value_type , typename other_container > void \fBmake_vector_default\fP (container &vec, const value_type &val, const other_container &other_vec)"
.br
.ti -1c
.RI "template<typename container > void \fBmake_vector_zeroes\fP (container &vec, const typename \fBcontainer::size_type\fP &d1)"
.br
.ti -1c
.RI "template<typename container , typename\&.\&.\&. Args> void \fBmake_vector_zeroes\fP (container &vec, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"
.br
.ti -1c
.RI "template<int_type d, typename container , typename value_type , typename other_container > void \fBmake_vector_zeroes\fP (container &vec, const value_type &val, const other_container &other_vec)"
.br
.ti -1c
.RI "template<typename container , typename val_type > void \fBmake_vector_value\fP (container &vec, const val_type &val, const typename \fBcontainer::size_type\fP &d1)"
.br
.ti -1c
.RI "template<typename container , typename val_type , typename\&.\&.\&. Args> void \fBmake_vector_value\fP (container &vec, const val_type &val, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"
.br
.ti -1c
.RI "template<int_type d, typename container , typename value_type , typename other_container > void \fBmake_vector_value\fP (container &vec, const value_type &val, const other_container &other_vec)"
.br
.ti -1c
.RI "template<typename container , typename func_type > void \fBmake_vector_function\fP (container &vec, const func_type &func, const typename \fBcontainer::size_type\fP &d1)"
.br
.ti -1c
.RI "template<typename container , typename func_type , typename\&.\&.\&. Args> void \fBmake_vector_function\fP (container &vec, const func_type &func, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"
.br
.ti -1c
.RI "template<int_type d, typename container , typename func_type , typename other_container > void \fBmake_vector_function\fP (container &vec, const func_type &func, const other_container &other_vec)"
.br
.ti -1c
.RI "template<int_type d, typename container , typename other_container > void \fBmake_vector_coerce\fP (container &vec, const other_container &other_vec)"
.br
.ti -1c
.RI "template<typename T1 > void \fBconcatenate\fP (T1 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > void \fBconcatenate\fP (T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 > void \fBconcatenate_map\fP (T1 &v1, const T1 &v2)"
.br
.ti -1c
.RI "template<typename T > std::vector< std::vector< T > > \fBpad\fP (const std::vector< std::vector< T > > &v, const T &default_value=T())"
.br
.ti -1c
.RI "template<typename T > std::vector< std::vector< T > > \fBtranspose\fP (const std::vector< std::vector< T > > &v, const T &default_value=T())"
.br
.ti -1c
.RI "template<typename T > std::vector< std::vector< T > > \fBreverse_vertical\fP (const std::vector< std::vector< T > > &v)"
.br
.ti -1c
.RI "template<typename T , typename A > void \fBswap\fP (\fBmulti_vector\fP< T, A > &v1, \fBmulti_vector\fP< T, A > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator+\fP (\fBmulti_vector\fP< T1, A1 > v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator+\fP (\fBmulti_vector\fP< T1, A1 > v1, const std::vector< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator+\fP (const std::vector< T1, A1 > &v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator+\fP (\fBmulti_vector\fP< T1, A1 > v1, T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T2, A2 > \fBoperator+\fP (T1 v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator-\fP (\fBmulti_vector\fP< T1, A1 > v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator-\fP (\fBmulti_vector\fP< T1, A1 > v1, const std::vector< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator-\fP (const std::vector< T1, A1 > &v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator-\fP (\fBmulti_vector\fP< T1, A1 > v1, T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T2, A2 > \fBoperator-\fP (T1 v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator*\fP (\fBmulti_vector\fP< T1, A1 > v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator*\fP (\fBmulti_vector\fP< T1, A1 > v1, const std::vector< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator*\fP (const std::vector< T1, A1 > &v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator*\fP (\fBmulti_vector\fP< T1, A1 > v1, T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T2, A2 > \fBoperator*\fP (T1 v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator/\fP (\fBmulti_vector\fP< T1, A1 > v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator/\fP (\fBmulti_vector\fP< T1, A1 > v1, const std::vector< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator/\fP (const std::vector< T1, A1 > &v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP< T1, A1 > \fBoperator/\fP (\fBmulti_vector\fP< T1, A1 > v1, T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T2, A2 > \fBoperator/\fP (T1 v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator==\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const std::vector< bool > & \fBoperator==\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator==\fP (const T1 v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator!=\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const std::vector< bool > & \fBoperator!=\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator!=\fP (const T1 v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator<\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const std::vector< bool > & \fBoperator<\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator<\fP (const T1 v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator>\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const std::vector< bool > & \fBoperator>\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator>\fP (const T1 v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator<=\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const std::vector< bool > & \fBoperator<=\fP (const \fBmulti_vector\fP< T1, A1 > &v1, T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator<=\fP (const T1 v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator>=\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const std::vector< bool > & \fBoperator>=\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const T2 v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const std::vector< bool > & \fBoperator>=\fP (const T1 v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP< T, A > \fBmin\fP (\fBmulti_vector\fP< T, A > v1, const \fBmulti_vector\fP< T_o, A_o > &v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP< T, A > \fBmin\fP (\fBmulti_vector\fP< T, A > v1, const std::vector< T_o, A_o > &v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP< T, A > \fBmin\fP (const std::vector< T, A > &v1, const \fBmulti_vector\fP< T_o, A_o > &v2)"
.br
.ti -1c
.RI "template<typename T , typename T_o , typename A_o > \fBmulti_vector\fP< T_o, A_o > \fBmin\fP (T v1, \fBmulti_vector\fP< T_o, A_o > v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o > \fBmulti_vector\fP< T, A > \fBmin\fP (\fBmulti_vector\fP< T, A > v1, const T_o v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP< T, A > \fBmax\fP (\fBmulti_vector\fP< T, A > v1, const \fBmulti_vector\fP< T_o, A_o > &v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP< T, A > \fBmax\fP (\fBmulti_vector\fP< T, A > v1, const std::vector< T_o, A_o > &v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP< T, A > \fBmax\fP (const std::vector< T, A > &v1, const \fBmulti_vector\fP< T_o, A_o > &v2)"
.br
.ti -1c
.RI "template<typename T , typename T_o , typename A_o > \fBmulti_vector\fP< T_o, A_o > \fBmax\fP (const T v1, \fBmulti_vector\fP< T_o, A_o > v2)"
.br
.ti -1c
.RI "template<typename T , typename A , typename T_o > \fBmulti_vector\fP< T, A > \fBmax\fP (\fBmulti_vector\fP< T, A > v1, const T_o v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBpow\fP (\fBmulti_vector\fP< T1, A1 > v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP< T1, A1 > \fBpow\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T2, A2 > \fBpow\fP (const T1 &v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T1, A1 > \fBsafe_pow\fP (\fBmulti_vector\fP< T1, A1 > v1, const \fBmulti_vector\fP< T2, A2 > &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP< T1, A1 > \fBsafe_pow\fP (const \fBmulti_vector\fP< T1, A1 > &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP< T2, A2 > \fBsafe_pow\fP (const T1 &v1, \fBmulti_vector\fP< T2, A2 > v2)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBoperator-\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBabs\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBsqrt\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBsafe_sqrt\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBexp\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBsquare\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBcube\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBquart\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBinverse\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBinv_square\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBinv_cube\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBinv_quart\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const \fBmulti_vector\fP< T, A > \fBsafe_d\fP (\fBmulti_vector\fP< T, A > v)"
.br
.ti -1c
.RI "template<typename T , typename A > const T \fBsum\fP (const \fBIceBRG::multi_vector\fP< T, A > &v)"
.br
.ti -1c
.RI "template<typename T , typename A > const T \fBproduct\fP (const \fBIceBRG::multi_vector\fP< T, A > &v)"
.br
.ti -1c
.RI "template<typename T , typename A > const T \fBmean\fP (const \fBIceBRG::multi_vector\fP< T, A > &v)"
.br
.ti -1c
.RI "template<typename T , typename A > const T \fBstd\fP (const \fBIceBRG::multi_vector\fP< T, A > &v)"
.br
.ti -1c
.RI "template<typename T , typename A > const T \fBstddev\fP (const \fBIceBRG::multi_vector\fP< T, A > &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Index \fBrsize\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> \fBssize_t\fP \fBrsize\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!IceBRG::is_eigen_container< T >::value, char >::type  = 0> T \fBsum\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type \fBsum\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Scalar \fBproduct\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!IceBRG::is_eigen_container< T >::value, char >::type  = 0> T \fBproduct\fP (const T v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type \fBproduct\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type \fBmean\fP (const std::vector< T > &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Scalar \fBmean\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type \fBstd\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type \fBstddev\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Scalar \fBstd\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Scalar \fBstddev\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type \fBstderr\fP (const T &v)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Scalar \fBstderr\fP (const T &v)"
.br
.ti -1c
.RI "template<typename InputIterator > bool \fBis_monotonically_increasing\fP (const InputIterator &first, const InputIterator &last)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value||IceBRG::is_eigen_container< T >::value, char >::type  = 0> bool \fBis_monotonically_increasing\fP (const T &v)"
.br
.ti -1c
.RI "template<typename InputIterator > bool \fBis_monotonically_decreasing\fP (const InputIterator &first, const InputIterator &last)"
.br
.ti -1c
.RI "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value||IceBRG::is_eigen_container< T >::value, char >::type  = 0> bool \fBis_monotonically_decreasing\fP (const T &v)"
.br
.ti -1c
.RI "bool \fBall_true\fP (const std::vector< bool > &vec)"
.br
.ti -1c
.RI "constexpr bool \fBall_true\fP (bool v)"
.br
.ti -1c
.RI "bool \fBall_false\fP (const std::vector< bool > &vec)"
.br
.ti -1c
.RI "constexpr bool \fBall_false\fP (const bool &v)"
.br
.ti -1c
.RI "bool \fBnot_all_true\fP (const std::vector< bool > &v)"
.br
.ti -1c
.RI "constexpr bool \fBnot_all_true\fP (const bool &v)"
.br
.ti -1c
.RI "bool \fBnot_all_false\fP (const std::vector< bool > &v)"
.br
.ti -1c
.RI "constexpr bool \fBnot_all_false\fP (bool v)"
.br
.ti -1c
.RI "bool \fBsome_true_some_false\fP (const std::vector< bool > &v)"
.br
.ti -1c
.RI "constexpr bool \fBsome_true_some_false\fP (const bool &v)"
.br
.ti -1c
.RI "const \fBvelocity_type\fP \fBc\fP (\fBIceBRG::unitconv::ctomps\fP *\fBmps\fP)"
.br
.ti -1c
.RI "const \fBinverse_time_type\fP \fBH_0\fP (70 *\fBunitconv::kmtom\fP/\fBunitconv::stos\fP/\fBunitconv::Mpctom\fP/\fBIceBRG::second\fP)"
.br
.ti -1c
.RI "\fBinverse_time_type\fP \fBH\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "custom_unit_type< 1, 0, 0,-1, 0 > \fBdfa\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBdfa\fP (const \fBangle_type\fP &da, const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBdfa\fP (const \fBangle_type\fP &a1, const \fBangle_type\fP &a2, const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBdfa\fP (const \fBangle_type\fP &a1x, const \fBangle_type\fP &a1y, const \fBangle_type\fP &a2x, const \fBangle_type\fP &a2y, const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "custom_unit_type<-1, 0, 0, 1, 0 > \fBafd\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBangle_type\fP \fBafd\fP (const \fBdistance_type\fP &dd, const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBangle_type\fP \fBafd\fP (const \fBdistance_type\fP &d1, const \fBdistance_type\fP &d2, const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBangle_type\fP \fBafd\fP (const \fBdistance_type\fP &d1x, const \fBdistance_type\fP &d1y, const \fBdistance_type\fP &d2x, const \fBdistance_type\fP &d2y, const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBflt_type\fP \fBzfa\fP (const \fBflt_type\fP &a)"
.br
.ti -1c
.RI "\fBflt_type\fP \fBafz\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBtime_type\fP \fBtfz\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBtime_type\fP \fBtfa\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBflt_type\fP \fBzft\fP (const \fBtime_type\fP &t)"
.br
.ti -1c
.RI "\fBflt_type\fP \fBaft\fP (const \fBtime_type\fP &t)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_add\fP (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_cmd\fP (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_Ld\fP (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_ltd\fP (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_add\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_cmd\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_Ld\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_ltd\fP (const \fBflt_type\fP &z)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBintegrate_distance\fP (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2, const \fBint_type\fP &mode, const \fBint_type\fP &resolution=10000)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBad_distance\fP (\fBflt_type\fP z1, \fBflt_type\fP z2=0)"
.br
.ti -1c
.RI "\fBsurface_density_type\fP \fBsigma_crit\fP (const \fBflt_type\fP &z_lens, const \fBflt_type\fP &z_source)"
.br
.ti -1c
.RI "template<typename Tr1 , typename Td1 , typename Tr2 , typename Td2 > const Tr1 \fBskydist2d\fP (const Tr1 &ra1, const Td1 &dec1, const Tr2 &ra2, const Td2 &dec2)"
.br
.ti -1c
.RI "\fBtime_type\fP \fBperiod\fP (const \fBdensity_profile\fP *host, const \fBdistance_type\fP &r, const \fBvelocity_type\fP &vr, const \fBvelocity_type\fP &vt=0)"
.br
.ti -1c
.RI "\fBdistance_type\fP \fBdfa\fP (const \fBsky_obj\fP *obj1, const \fBsky_obj\fP *obj2, const \fBflt_type\fP &z=-1\&.)"
.br
.ti -1c
.RI "\fBangle_type\fP \fBskydist2d\fP (const \fBsky_obj\fP *obj1, const \fBsky_obj\fP *obj2)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "constexpr \fBflt_type\fP \fBdelta_c\fP = 1\&.686"
.br
.ti -1c
.RI "const \fBflt_type\fP & \fBmin_x\fP = 0\&.000001"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_m_counting_min\fP = 19"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_m_counting_max\fP = 24\&.7"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_m_min\fP = 20"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_m_max\fP = 24\&.7"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_m_step\fP = 0\&.1"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_z_min\fP = 0\&.2"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_z_max\fP = 4\&.0"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_z_step\fP = 0\&.01"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_lens_T_min\fP = 2\&.0"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_lens_T_max\fP = 4\&.0"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBmag_min_count\fP = 0\&.1"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBtest_fudge_factor\fP = 1\&."
.br
.ti -1c
.RI "\fBerror_behavior_type\fP \fBerror_behavior\fP = error_behavior_type::WARN"
.br
.ti -1c
.RI "\fBf_in_2\fP"
.br
.ti -1c
.RI "std::ranlux48 \fBrng\fP"
.br
.ti -1c
.RI "const auto \fBmeter\fP = boost::units::si::meter"
.br
.ti -1c
.RI "const auto \fBsecond\fP = boost::units::si::second"
.br
.ti -1c
.RI "const auto \fBkilogram\fP = boost::units::si::kilogram"
.br
.ti -1c
.RI "const auto \fBradian\fP = boost::units::si::radian"
.br
.ti -1c
.RI "const auto \fBm\fP = \fBmeter\fP"
.br
.ti -1c
.RI "const auto \fBs\fP = \fBsecond\fP"
.br
.ti -1c
.RI "const auto \fBkg\fP = \fBkilogram\fP"
.br
.ti -1c
.RI "const auto \fBrad\fP = \fBradian\fP"
.br
.ti -1c
.RI "const auto \fBmps\fP = \fBmeter_per_second\fP"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBGc\fP = 6\&.67384e-11"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBOmega_m\fP = 0\&.288"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBOmega_r\fP = 0\&.000086"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBOmega_k\fP = 0"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBOmega_l\fP = 1 - \fBOmega_k\fP - \fBOmega_m\fP - \fBOmega_r\fP"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBOmega_b\fP = 0\&.0472"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBsigma_8\fP = 0\&.830"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBn_s\fP = 0\&.971"
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBdefault_c\fP = 6\&."
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBdefault_tau_factor\fP = 2\&."
.br
.ti -1c
.RI "constexpr \fBflt_type\fP \fBvirial_density_factor\fP = 200\&."
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct IceBRG::all_flt_type"
.PP 

.SS "template<typename T, typename Enable = void>struct IceBRG::all_flt_type< T, Enable >"

.SH "struct IceBRG::_is_boost_tuple< boost::tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9 > >"
.PP 

.SS "template<class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9>struct IceBRG::_is_boost_tuple< boost::tuple< T0, T1, T2, T3, T4, T5, T6, T7, T8, T9 > >"

.SH "struct IceBRG::_is_boost_tuple< boost::tuples::cons< TH, TT > >"
.PP 

.SS "template<class TH, class TT>struct IceBRG::_is_boost_tuple< boost::tuples::cons< TH, TT > >"

.SH "struct IceBRG::_is_boost_tuple< boost::tuples::null_type >"
.PP 

.SS "template<>struct IceBRG::_is_boost_tuple< boost::tuples::null_type >"

.SH "struct IceBRG::_is_null_type< boost::tuples::null_type >"
.PP 

.SS "template<>struct IceBRG::_is_null_type< boost::tuples::null_type >"

.SH "struct IceBRG::is_container"
.PP 

.SS "template<typename T>struct IceBRG::is_container< T >"

.SH "struct IceBRG::is_container_or_boost_tuple"
.PP 

.SS "template<typename T>struct IceBRG::is_container_or_boost_tuple< T >"

.SH "struct IceBRG::is_scalar"
.PP 

.SS "template<typename T>struct IceBRG::is_scalar< T >"

.SH "struct IceBRG::is_scalar_or_eigen"
.PP 

.SS "template<typename T>struct IceBRG::is_scalar_or_eigen< T >"

.SH "struct IceBRG::is_eigen_container"
.PP 

.SS "template<typename T>struct IceBRG::is_eigen_container< T >"

.SH "struct IceBRG::is_stl_container"
.PP 

.SS "template<typename T>struct IceBRG::is_stl_container< T >"

.SH "struct IceBRG::labeled_array_iterator_chooser"
.PP 

.SS "template<typename value_type, char tag>struct IceBRG::labeled_array_iterator_chooser< value_type, tag >"

.SH "Typedef Documentation"
.PP 
.SS "typedef boost::units::quantity<boost::units::si::acceleration> \fBIceBRG::acceleration_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::plane_angle> \fBIceBRG::angle_type\fP"

.SS "typedef boost::any \fBIceBRG::any_units_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::area> \fBIceBRG::area_type\fP"

.SS "typedef Eigen::Array<\fBcomplex_type\fP,Eigen::Dynamic,1> \fBIceBRG::complex_array_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::mass_density> \fBIceBRG::density_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::dimensionless> \fBIceBRG::dimensionless_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::length> \fBIceBRG::distance_type\fP"

.SS "typedef Eigen::Array<\fBflt_type\fP,Eigen::Dynamic,1> \fBIceBRG::flt_array_type\fP"

.SS "typedef std::vector< std::string > \fBIceBRG::header_t\fP"

.SS "typedef Eigen::Array<\fBint_type\fP,Eigen::Dynamic,1> \fBIceBRG::int_array_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::wavenumber> \fBIceBRG::inverse_distance_type\fP"

.SS "typedef custom_unit_type<0,0,0,-2,0> \fBIceBRG::inverse_square_angle\fP"

.SS "typedef boost::units::quantity<boost::units::si::frequency> \fBIceBRG::inverse_time_type\fP"

.SS "typedef Eigen::Array<\fBlong_complex_type\fP,Eigen::Dynamic,1> \fBIceBRG::long_complex_array_type\fP"

.SS "typedef Eigen::Array<\fBlong_flt_type\fP,Eigen::Dynamic,1> \fBIceBRG::long_flt_array_type\fP"

.SS "typedef Eigen::Array<\fBlong_int_type\fP,Eigen::Dynamic,1> \fBIceBRG::long_int_array_type\fP"

.SS "typedef Eigen::Array<\fBlong_unsigned_int_type\fP,Eigen::Dynamic,1> \fBIceBRG::long_unsigned_int_array_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::mass> \fBIceBRG::mass_type\fP"

.SS "typedef Eigen::Array<\fBshort_int_type\fP,Eigen::Dynamic,1> \fBIceBRG::short_int_array_type\fP"

.SS "typedef Eigen::Array<\fBshort_unsigned_int_type\fP,Eigen::Dynamic,1> \fBIceBRG::short_unsigned_int_array_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::surface_density> \fBIceBRG::surface_density_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::temperature> \fBIceBRG::temperature_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::time> \fBIceBRG::time_type\fP"

.SS "typedef std::map<std::string,\fBflt_type\fP> \fBIceBRG::unitconv_map\fP"

.SS "typedef Eigen::Array<\fBunsigned_int_type\fP,Eigen::Dynamic,1> \fBIceBRG::unsigned_int_array_type\fP"

.SS "typedef boost::units::quantity<boost::units::si::velocity> \fBIceBRG::velocity_type\fP"

.SH "Enumeration Type Documentation"
.PP 
.SS "anonymous enum"

.PP
\fBEnumerator: \fP
.in +1c
.TP
\fB\fIforward_tag \fP\fP
.TP
\fB\fIreverse_tag \fP\fP

.SS "enum \fBIceBRG::error_behavior_type\fP"

.PP
Error behavior enum\&. 
.SH "Function Documentation"
.PP 
.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, T >::type *  = nullptr> T IceBRG::_runtime_ipow (Tv, \fBint_type\fPp)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::above_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::above_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> T IceBRG::abs (const T &x)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::abs (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::abs (multi_vector< T, A >v)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > T1 IceBRG::abs (const T1 &t1)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> T IceBRG::acos (const T &x)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > \fBtuples::asct_typeof_helper\fP< T1 >::type IceBRG::acos (const T1 &t1)\fC [inline]\fP"

.SS "\fBIceBRG::distance_type\fP IceBRG::ad_distance (\fBflt_type\fPz1, \fBflt_type\fPz2 = \fC0\fP)"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto IceBRG::add (const T1 &v1, const T2 &v2)"

.SS "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type IceBRG::add (T1 &&, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::add_typeof_helper\fP< T1, T2 >::type IceBRG::add (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1& IceBRG::add_equal (const T1 &t1, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & IceBRG::add_equal (T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & IceBRG::add_equal (T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1& IceBRG::add_equal (const T1 &v1, const T2 &v2)"

.SS "IceBRG::custom_unit_type<-1, 0, 0, 1, 0 > IceBRG::afd (const \fBflt_type\fP &z)"

.SS "\fBIceBRG::angle_type\fP IceBRG::afd (const distance_type &dd, const \fBflt_type\fP &z)"

.SS "\fBIceBRG::angle_type\fP IceBRG::afd (const distance_type &d1, const distance_type &d2, const \fBflt_type\fP &z)"

.SS "\fBIceBRG::angle_type\fP IceBRG::afd (const distance_type &d1x, const distance_type &d1y, const distance_type &d2x, const distance_type &d2y, const \fBflt_type\fP &z)"

.SS "\fBflt_type\fP IceBRG::aft (const time_type &t)"

.SS "\fBflt_type\fP IceBRG::afz (const \fBflt_type\fP &z)"

.SS "bool IceBRG::all_false (const std::vector< bool > &vec)\fC [inline]\fP"

.SS "constexpr bool IceBRG::all_false (const bool &v)\fC [inline]\fP"

.SS "bool IceBRG::all_true (const std::vector< bool > &vec)\fC [inline]\fP"

.SS "constexpr bool IceBRG::all_true (boolv)\fC [inline]\fP"

.SS "template<typename Tout , typename Tin > \fBany_units_type\fP IceBRG::any_units_cast (const Tin &x)"

.SS "template<typename f , typename T > T IceBRG::apply (const f &func, Tv1)"

.SS "template<typename f , typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1 IceBRG::apply (const f &func, T1v1, const T2 &v2)"

.SS "template<typename f , typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T2 IceBRG::apply (const f &func, const T1 &v1, T2v2)"

.SS "template<typename f , typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 IceBRG::apply (const f &func, const T1 &v1, const T2 &v2)"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> T IceBRG::asin (const T &x)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > \fBtuples::asct_typeof_helper\fP< T1 >::type IceBRG::asin (const T1 &t1)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP IceBRG::atan (const T &y)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > \fBtuples::asct_typeof_helper\fP< T1 >::type IceBRG::atan (const T1 &t1)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP IceBRG::atan2 (const T &y, const T &x = \fC1\&.\fP)"

.SS "template<typename T , BRG_F_IS_CONTAINER(T) > auto IceBRG::attempt_get (T &v, const \fBint_type\fP &i)"

.SS "template<typename f > void IceBRG::binary_for_each (const f &func, const boost::tuples::null_type &, const boost::tuples::null_type &)\fC [inline]\fP"

.SS "template<typename f , class Th , class Tt , typename T2 > void IceBRG::binary_for_each (const f &func, const boost::tuples::cons< Th, Tt > &t1, T2 &&t2)\fC [inline]\fP"

.SS "template<typename f , class Th , class Tt , typename T2 > void IceBRG::binary_for_each (const f &func, boost::tuples::cons< Th, Tt > &t1, T2 &&t2)\fC [inline]\fP"

.SS "template<typename T , typename T_test  = T, typename std::enable_if<!IceBRG::is_stl_container< T_test >::value, char >::type  = 0> T IceBRG::binary_load (boost::archive::binary_iarchive &ar)"

.SS "template<typename T , typename T_test  = T, typename std::enable_if< IceBRG::is_stl_container< T_test >::value, char >::type  = 0, typename std::enable_if< std::is_same< typename T_test::value_type, bool >::value, char >::type  = 0> T IceBRG::binary_load (boost::archive::binary_iarchive &ar)"

.SS "template<typename T > T IceBRG::binary_load (std::istream &in)"

.SS "template<typename T > T IceBRG::binary_load (const std::string &filename)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0> void IceBRG::binary_save (boost::archive::binary_oarchive &ar, const T &obj)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< std::is_same< typename T::value_type, bool >::value, char >::type  = 0> void IceBRG::binary_save (boost::archive::binary_oarchive &ar, const T &obj)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!std::is_same< typename T::value_type, bool >::value, char >::type  = 0> void IceBRG::binary_save (boost::archive::binary_oarchive &ar, const std::vector< T > &obj)"

.SS "template<typename T > void IceBRG::binary_save (std::ostream &out, const T &obj)"

.SS "template<typename T > void IceBRG::binary_save (const std::string &filename, const T &obj)"

.SS "bool IceBRG::bool_cast (const std::string &s)\fC [inline]\fP"

.SS "template<class T1 , class T2 , class T3 , BRG_F_NOT_CONTAINER(T1) , BRG_F_NOT_CONTAINER(T2) , BRG_F_NOT_CONTAINER(T3) > T2 IceBRG::bound (T1 &&lower_bound, T2 &&a, T3 &&upper_bound)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , typename T3 , typename std::enable_if< IceBRG::is_stl_container< T1 >::value||IceBRG::is_eigen_container< T1 >::value||IceBRG::is_stl_container< T2 >::value||IceBRG::is_eigen_container< T2 >::value||IceBRG::is_stl_container< T3 >::value||IceBRG::is_eigen_container< T3 >::value, char >::type  = 0> T2 IceBRG::bound (T1 &&lower_bound, T2 &&a, T3 &&upper_bound)"

.SS "const \fBvelocity_type\fP IceBRG::c (\fBIceBRG::unitconv::ctomps\fP *mps)"

.SS "template<typename\&.\&.\&. Args> void IceBRG::call_program (const char *program_name, \fBint_type\fPnum_retries, Args\&.\&.\&.args)"

.SS "template<typename\&.\&.\&. Args> \fBint_type\fP IceBRG::call_program_noexcept (const char *program_name, \fBint_type\fPnum_retries, Args\&.\&.\&.args)"

.SS "\fBint_type\fP IceBRG::call_program_noexcept (const char *program_name)\fC [inline]\fP"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_above_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_above_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP IceBRG::checked_get_bin_index (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP IceBRG::checked_get_bin_index (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_inside_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_inside_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_outside_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_outside_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_under_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::checked_under_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename NewType , int_type d = 1, typename OldType  = NewType> NewType IceBRG::coerce (const OldType &old)"
coerce - helper function which returns a coercion of old into NewType\&.
.PP
\fBParameters:\fP
.RS 4
\fIold\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename T1 > void IceBRG::concatenate (T1 &v1, const T1 &v2)"

.SS "template<typename T1 , typename T2 > void IceBRG::concatenate (T1 &v1, const T2 &v2)"

.SS "template<typename T1 > void IceBRG::concatenate_map (T1 &v1, const T1 &v2)"

.SS "\fBheader_t\fP IceBRG::convert_to_header (const std::string &line)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP IceBRG::cos (const T &x)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > \fBtuples::sct_typeof_helper\fP< T1 >::type IceBRG::cos (const T1 &t1)\fC [inline]\fP"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::cube (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::cube (multi_vector< T, A >v)"

.SS "typedef IceBRG::decltype (angle_type()*angle_type())"

.SS "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > IceBRG::decltype (T()*T()) const"

.SS "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > IceBRG::decltype (T()*square(T())) const"

.SS "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > IceBRG::decltype (square(T())*square(T())) const"

.SS "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > IceBRG::decltype (1/T()) const"

.SS "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > IceBRG::decltype (inverse(square(T()))) const"

.SS "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > IceBRG::decltype (inverse(cube(T()))) const"

.SS "template<typename T , BRG_F_IS_EIGEN_OR_SCALAR(T) > IceBRG::decltype (inverse(quart(T()))) const"

.SS "IceBRG::custom_unit_type< 1, 0, 0,-1, 0 > IceBRG::dfa (const \fBflt_type\fP &z)"

.SS "\fBIceBRG::distance_type\fP IceBRG::dfa (const angle_type &da, const \fBflt_type\fP &z)"

.SS "\fBIceBRG::distance_type\fP IceBRG::dfa (const angle_type &a1, const angle_type &a2, const \fBflt_type\fP &z)"

.SS "\fBIceBRG::distance_type\fP IceBRG::dfa (const angle_type &a1x, const angle_type &a1y, const angle_type &a2x, const angle_type &a2y, const \fBflt_type\fP &z)"

.SS "\fBIceBRG::distance_type\fP IceBRG::dfa (const sky_obj *obj1, const sky_obj *obj2, const \fBflt_type\fP &z = \fC-1\&.\fP)"

.SS "template<typename f , typename T > T IceBRG::differentiate (const f *func, const T &in_param, const \fBint_type\fPorder = \fC1\fP, const \fBflt_type\fP &power = \fC1\fP, const T &factor = \fC\fBSMALL_FACTOR\fP\fP)\fC [inline]\fP"

.SS "template<typename f , typename T > std::vector< std::vector< T > > IceBRG::differentiate (const f *func, const std::vector< T > &in_params, const \fBint_type\fPorder = \fC1\fP, const \fBflt_type\fP &power = \fC1\fP)\fC [inline]\fP"

.SS "template<typename Tx1 , typename Ty1 , typename Tx2 , typename Ty2 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tx2) , BRG_F_IS_EIGEN_OR_SCALAR(Ty2) > Tx1 IceBRG::dist2d (const Tx1 &x1, const Ty1 &y1, const Tx2 &x2, const Ty2 &y2)\fC [inline]\fP"

.SS "template<typename Tx1 , typename Ty1 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) > Tx1 IceBRG::dist2d (const Tx1 &x1, const Ty1 &y1)\fC [inline]\fP"

.SS "template<typename Tx1 , typename Ty1 , typename Tz1 , typename Tx2 , typename Ty2 , typename Tz2 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tz1) , BRG_F_IS_EIGEN_OR_SCALAR(Tx2) , BRG_F_IS_EIGEN_OR_SCALAR(Ty2) , BRG_F_IS_EIGEN_OR_SCALAR(Tz2) > Tx1 IceBRG::dist3d (const Tx1 &x1, const Ty1 &y1, const Tz1 &z1, const Tx2 &x2, const Ty2 &y2, const Tz2 &z2)\fC [inline]\fP"

.SS "template<typename Tx1 , typename Ty1 , typename Tz1 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tz1) > Tx1 IceBRG::dist3d (const Tx1 &x1, const Ty1 &y1, const Tz1 &z1)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto IceBRG::divide (const T1 &v1, const T2 &v2)"

.SS "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type IceBRG::divide (T1 &&, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::divide_typeof_helper\fP< T1, T2 >::type IceBRG::divide (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1& IceBRG::divide_equal (const T1 &t1, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & IceBRG::divide_equal (T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & IceBRG::divide_equal (T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1& IceBRG::divide_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename Ta , typename Tb > bool IceBRG::divisible (const Ta &a, const Tb &b)\fC [inline]\fP"

.SS "template<typename Tx1 , typename Ty1 , typename Tz1 , typename Tx2 , typename Ty2 , typename Tz2 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Tz1) , BRG_F_IS_EIGEN_OR_SCALAR(Tx2) , BRG_F_IS_EIGEN_OR_SCALAR(Ty2) , BRG_F_IS_EIGEN_OR_SCALAR(Tz2) > Tx1 IceBRG::dot_product (const Tx1 &x1, const Ty1 &y1, const Tz1 &z1, const Tx2 &x2, const Ty2 &y2, const Tz2 &z2)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NOT_CONTAINER(T1) , BRG_F_NOT_CONTAINER(T2) > T1 IceBRG::dot_product (const std::vector< T1 > &a, const std::vector< T2 > &b)\fC [inline]\fP"

.SS "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::drand (T_gen &gen = \fCrng\fP)"

.SS "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::drand (T_in &&min, T_in &&max, T_gen &gen = \fCrng\fP)"

.SS "template<typename T1 , typename T2 > bool IceBRG::equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector<bool> IceBRG::equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 > std::vector<bool> IceBRG::equal (const T2 &v1, const T1 &v2)"

.SS "template<typename Tx > Tx IceBRG::erf (Tx &&x)\fC [inline]\fP"

.SS "template<typename Tx > Tx IceBRG::erfc (Tx &&x)\fC [inline]\fP"

.SS "std::string IceBRG::exec (const char *cmd)\fC [inline]\fP"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::exp (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::exp (multi_vector< T, A >v)"

.SS "template<typename Ti > auto IceBRG::extract_count (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_effective_count (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_error_of_mean (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_error_of_weighted_mean (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_mean (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_mean_weight (Ti &&acc)"

.SS "template<int_type n, typename Ti > auto IceBRG::extract_moment (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_sum (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_sum_of_square_weights (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_sum_of_weights (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_variance (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_weighted_mean (Ti &&acc)"

.SS "template<int_type n, typename Ti > auto IceBRG::extract_weighted_moment (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_weighted_sum (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::extract_weighted_variance (Ti &&acc)"

.SS "template<typename T , BRG_F_IS_CONTAINER(T) > void IceBRG::fix_min_and_max (T &v1, T &v2)"

.SS "template<typename T , BRG_F_IS_NULL(T) > void IceBRG::fix_min_and_max (const T &v1, const T &v2)"

.SS "template<typename T , BRG_F_IS_CONTAINER(T) > void IceBRG::fix_step_sigmas (T &v_sigmas, const T &v_min, const T &v_max)"

.SS "template<typename T , BRG_F_IS_NULL(T) > void IceBRG::fix_step_sigmas (const T &v_sigmas, const T &v_min, const T &v_max)"

.SS "template<typename T , BRG_F_IS_CONTAINER(T) > void IceBRG::fix_step_sigmas (const T &v_sigmas)"

.SS "template<typename T , BRG_F_IS_TUPLE(T) > void IceBRG::fix_step_sigmas (T &v_sigmas)"

.SS "template<typename T , typename std::enable_if<!boost::units::is_quantity< T >::value, char >::type  = 0> void IceBRG::fixbad (T &val)\fC [inline]\fP"

.SS "auto IceBRG::func2 (min_in_param)"

.SS "template<typename Tlo , typename Thi , typename Tmean , typename Tstddev > \fBflt_type\fP IceBRG::Gaus_int (const Tlomin, const Thimax)\fC [inline]\fP"

.SS "template<typename Tlo , typename Thi , typename Tmean > \fBflt_type\fP IceBRG::Gaus_int (const Tlomin, const Thimax, const Tmeanmean)\fC [inline]\fP"

.SS "template<typename Tlo , typename Thi , typename Tmean , typename Tstddev > \fBflt_type\fP IceBRG::Gaus_int (const Tlomin, const Thimax, const Tmeanmean, const Tstddevstd_dev)\fC [inline]\fP"

.SS "template<typename Tx , typename Tmean , typename Tstddev > \fBflt_type\fP IceBRG::Gaus_pdf (const Txx, const Tmeanmean, const Tstddevstd_dev)\fC [inline]\fP"

.SS "template<typename Tx , typename Tmean > \fBflt_type\fP IceBRG::Gaus_pdf (const Txx, const Tmeanmean)\fC [inline]\fP"

.SS "template<typename Tx > \fBflt_type\fP IceBRG::Gaus_pdf (const Txx)\fC [inline]\fP"

.SS "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::Gaus_rand (T_gen &gen = \fCrng\fP)"

.SS "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::Gaus_rand (T_in &&mean, T_in &&stddev = \fC1\&.0\fP, T_gen &gen = \fCrng\fP)"

.SS "template<typename T , BRG_F_IS_CONTAINER(T) > auto IceBRG::get (T &v, const \fBint_type\fP &i)"

.SS "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP IceBRG::get_bin_index (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP IceBRG::get_bin_index (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP IceBRG::get_bin_index_no_overflow (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> \fBssize_t\fP IceBRG::get_bin_index_no_overflow (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename T1 , typename A1  = std::allocator<T1>> std::vector<T1,A1> IceBRG::get_bin_limits_from_mids (std::vector< T1, A1 >vec)"

.SS "template<typename T1 , typename A1  = std::allocator<T1>> std::vector<T1,A1> IceBRG::get_bin_mids_from_limits (std::vector< T1, A1 >vec)"

.SS "template<typename T1 , typename A1  = std::allocator<T1>> std::vector<T1,A1> IceBRG::get_bin_mids_from_limits (const \fBIceBRG::limit_vector\fP< T1, A1 > &vec)"

.SS "template<typename T_vec , typename T_gen  = decltype(rng)> T_vec IceBRG::get_case_resampled (const T_vec &vec, T_gen &gen = \fCrng\fP)"

.SS "template<typename To > To IceBRG::get_cline_arg (const int &argc, const char *argv[], const int &i)\fC [inline]\fP"
Try to get a command-line argument, and throw an exception if it's not present\&.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP 
.br
\fIargv\fP 
.br
\fIi\fP Position of the argument to take (remember that cline args start at 1)\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename To > To IceBRG::get_cline_arg (const int &argc, const char *argv[], const int &i, const std::function< bool(const To &)> &test)\fC [inline]\fP"
Try to get a command-line argument, throw an exception if it's not present or if it fails the provided test\&.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP 
.br
\fIargv\fP 
.br
\fIi\fP Position of the argument to take (remember that cline args start at 1)\&. 
.br
\fItest\fP Test on the argument\&. Must take a value of the output type and return a bool, which will be true on a pass\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename To > To IceBRG::get_cline_arg (const int &argc, const char *argv[], const int &i, const To &default_out)\fC [inline]\fP"
Try to get a command-line argument, returns a default value if it isn't present\&.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP 
.br
\fIargv\fP 
.br
\fIi\fP Position of the argument to take (remember that cline args start at 1)\&. 
.br
\fIdefault_out\fP Default return value if the argument isn't present\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename To > To IceBRG::get_cline_arg (const int &argc, const char *argv[], const int &i, const std::function< bool(const To &)> &test, const To &default_out)\fC [inline]\fP"
Try to get a command-line argument, throw if it fails the provided test, if it's not present, test possible default values\&.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP 
.br
\fIargv\fP 
.br
\fIi\fP Position of the argument to take (remember that cline args start at 1)\&. 
.br
\fItest\fP Test on the argument\&. Must take a value of the output type and return a bool, which will be true on a pass\&. 
.br
\fIdefault_out\fP Default return value if the argument isn't present\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename To , typename\&.\&.\&. Tos> To IceBRG::get_cline_arg (const int &argc, const char *argv[], const int &i, const std::function< bool(const To &)> &test, const To &primary_default_out, const To &secondary_default_out, Tos\&.\&.\&.other_default_outs)\fC [inline]\fP"
Try to get a command-line argument, throw if it fails the provided test, if it's not present, test possible default values\&.
.PP
\fBParameters:\fP
.RS 4
\fIargc\fP 
.br
\fIargv\fP 
.br
\fIi\fP Position of the argument to take (remember that cline args start at 1)\&. 
.br
\fItest\fP Test on the argument\&. Must take a value of the output type and return a bool, which will be true on a pass\&. 
.br
\fIdefault_out\fP Default return value if the argument isn't present\&. 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename T_vec , std::enable_if< IceBRG::is_eigen_container< T_vec >::value, char >  = 0> T_vec IceBRG::get_jackknife_resampled (const T_vec &vec, const \fBint_type\fP &sample_num = \fC0\fP, const \fBint_type\fP &num_samples = \fC2\fP)"

.SS "table_map_t<\fBflt_type\fP> IceBRG::get_table_after_unitconv (table_map_t< \fBflt_type\fP >data_map, const unitconv_map &u_map)\fC [inline]\fP"
Note: for unit conversions here, use the standard form\&. That is, if you want units to be output in km, pass in \fBunitconv::kmtom\fP; 
.PP
\fBParameters:\fP
.RS 4
\fIdata_map\fP 
.br
\fIu_map\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename T > table_map_t<\fBflt_type\fP> IceBRG::get_table_after_unitconv (const table_map_t< T > &data_map, const unitconv_map &u_map)"
Note: for unit conversions here, use the standard form\&. That is, if you want units to be output in km, pass in \fBunitconv::kmtom\fP; 
.PP
\fBParameters:\fP
.RS 4
\fIdata_map\fP 
.br
\fIu_map\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename T1 , typename T2 > bool IceBRG::greater_than (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector<bool> IceBRG::greater_than (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 > std::vector<bool> IceBRG::greater_than (const T2 &v1, const T1 &v2)"

.SS "template<typename T1 , typename T2 > bool IceBRG::greater_than_or_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector<bool> IceBRG::greater_than_or_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 > std::vector<bool> IceBRG::greater_than_or_equal (const T2 &v1, const T1 &v2)"

.SS "\fBIceBRG::inverse_time_type\fP IceBRG::H (const \fBflt_type\fP &test_z)"
Function Declarations
.PP
Global Function Definitions 
.SS "const \fBinverse_time_type\fP IceBRG::H_0 (70 *unitconv::kmtom/unitconv::stos/unitconv::Mpctom/\fBIceBRG::second\fP)"

.SS "void IceBRG::handle_error (const std::string &str)\fC [inline]\fP"

.PP
Handle an error message\&. 
.SS "void IceBRG::handle_error_message (const std::string &str)\fC [inline]\fP"

.PP
Handle an error message when throwing isn't an option\&. 
.SS "void IceBRG::handle_notification (const std::string &str)\fC [inline]\fP"

.PP
Handle a notification\&. 
.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::inside_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::inside_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_add (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_add (const \fBflt_type\fP &z)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_cmd (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_cmd (const \fBflt_type\fP &z)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_distance (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2, const \fBint_type\fP &mode, const \fBint_type\fP &resolution = \fC10000\fP)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_Ld (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_Ld (const \fBflt_type\fP &z)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_ltd (const \fBflt_type\fP &z1, const \fBflt_type\fP &z2)"

.SS "\fBIceBRG::distance_type\fP IceBRG::integrate_ltd (const \fBflt_type\fP &z)"

.SS "template<typename f , typename T > auto IceBRG::integrate_mc (const f *func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBint_type\fPnum_samples)\fC [inline]\fP"

.SS "T auto IceBRG::integrate_product_Romberg (const f_in_1 &func1, const f_in_2 &func2, const T &min_in_param, const T &max_in_param, const \fBflt_type\fP &precision = \fC0\&.00001\fP, const booltighten_precision = \fCfalse\fP)\fC [inline]\fP"

.SS "template<typename f_in_1 , typename f_in_2 , typename T > auto IceBRG::integrate_product_Romberg (const f_in_1 &func1, const f_in_2 &func2, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBflt_type\fP &precision = \fC0\&.00001\fP, const booltighten_precision = \fCfalse\fP, const std::vector< T > &passed_in_param = \fCstd::vector< T >( 0 )\fP)\fC [inline]\fP"

.SS "Tin auto IceBRG::integrate_Romberg (const f &func, const Tin &min_in_param, const Tin &max_in_param, \fBflt_type\fPprecision = \fC0\&.00001\fP, booltighten_precision = \fCfalse\fP)\fC [inline]\fP"

.SS "template<typename f , typename T > auto IceBRG::integrate_Romberg (const f &func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBflt_type\fP &precision = \fC0\&.00001\fP, const booltighten_precision = \fCfalse\fP, const std::vector< T > &passed_in_param = \fCstd::vector< T >( 0 )\fP)\fC [inline]\fP"

.SS "template<typename f , typename T > auto IceBRG::integrate_trapezoid (const f *func, const T &min_in_param, const T &max_in_param, const T &in_param_step)\fC [inline]\fP"

.SS "template<typename f , typename T > auto IceBRG::integrate_trapezoid (const f *func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const std::vector< T > &in_param_step, const std::vector< T > &passed_in_param = \fCstd::vector< T >( 0 )\fP)\fC [inline]\fP"

.SS "T auto IceBRG::integrate_trapezoid (const f *func, const T &min_in_param, const T &max_in_param, const \fBint_type\fPnum_samples)\fC [inline]\fP"

.SS "template<typename f , typename T > auto IceBRG::integrate_trapezoid (const f *func, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBint_type\fPnum_samples, const std::vector< T > &passed_in_param = \fCstd::vector< T >( 0 )\fP)\fC [inline]\fP"

.SS "T auto IceBRG::integrate_weighted_Romberg (const f_in_1 &func, const f_in_2 &func_weight, const T &min_in_param, const T &max_in_param, const \fBflt_type\fP &precision = \fC0\&.00001\fP, const booltighten_precision = \fCfalse\fP)\fC [inline]\fP"

.SS "template<typename f_in_1 , typename f_in_2 , typename T > auto IceBRG::integrate_weighted_Romberg (const f_in_1 &func, const f_in_2 &func_weight, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBflt_type\fP &precision = \fC0\&.00001\fP, const booltighten_precision = \fCfalse\fP, const std::vector< T > &passed_in_param = \fCstd::vector< T >( 0 )\fP)\fC [inline]\fP"

.SS "template<typename f1 , typename f2 , typename T > auto IceBRG::integrate_weighted_trapezoid (const f1 *func, const f2 *func_weight, const T &min_in_param, const T &max_in_param, const T &in_param_step)\fC [inline]\fP"

.SS "template<typename f1 , typename f2 , typename T > auto IceBRG::integrate_weighted_trapezoid (const f1 *func, const f2 *func_weight, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const std::vector< T > &in_param_step, const std::vector< T > &passed_in_param = \fCstd::vector< T >( 0 )\fP)\fC [inline]\fP"

.SS "template<typename f1 , typename f2 , typename T > auto IceBRG::integrate_weighted_trapezoid (const f1 *func, const f2 *func_weight, const T &min_in_param, const T &max_in_param, const \fBint_type\fPnum_samples)\fC [inline]\fP"

.SS "template<typename f1 , typename f2 , typename T > auto IceBRG::integrate_weighted_trapezoid (const f1 *func, const f2 *func_weight, const std::vector< T > &min_in_param, const std::vector< T > &max_in_param, const \fBint_type\fPnum_samples, const std::vector< T > &passed_in_param = \fCstd::vector< T >( 0 )\fP)\fC [inline]\fP"

.SS "template<typename T1 , typename A1  = std::allocator<T1>, typename T2  = T1, typename A2  = std::allocator<T2>> T2 IceBRG::interpolate_bins (const T2 &val, const std::vector< T1, A1 > &lim_vec, const std::vector< T2, A2 > &val_vec)"

.SS "template<typename T1 , typename A1  = std::allocator<T1>, typename T2  = T1, typename A2  = std::allocator<T2>> T2 IceBRG::interpolate_bins (const T2 &val, const \fBIceBRG::limit_vector\fP< T1, A1 > &lim_vec, const std::vector< T2, A2 > &val_vec)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::inv_cube (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::inv_cube (multi_vector< T, A >v)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::inv_quart (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::inv_quart (multi_vector< T, A >v)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::inv_square (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::inv_square (multi_vector< T, A >v)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::inverse (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::inverse (multi_vector< T, A >v)"

.SS "template<int_type p> \fBflt_type\fP IceBRG::ipow (const \fBflt_type\fP &v)"

.SS "template<int_type e, typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> auto IceBRG::ipow (const T &x)"

.SS "template<int_type en, int_type ed, typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> auto IceBRG::ipow (const T &x)"

.SS "template<int_type p> boost::tuples::null_type IceBRG::ipow (const boost::tuples::null_type &t1)\fC [inline]\fP"

.SS "template<int_type p, class T1 , BRG_F_IS_TUPLE(T1) > \fBtuples::ipow_typeof_helper\fP<p,T1>::type IceBRG::ipow (const T1 &t1)\fC [inline]\fP"

.SS "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 IceBRG::ipow_err (const T1 &v, T1v_err, \fBint_type\fPp)\fC [inline]\fP"

.SS "template<typename T  = int_type, typename T_in  = int_type, typename T_gen  = decltype(rng)> T IceBRG::irand (T_in &&min, T_in &&max, T_gen &gen = \fCrng\fP)"
Global function declarations 
.SS "template<typename InputIterator > bool IceBRG::is_monotonically_decreasing (const InputIterator &first, const InputIterator &last)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value||IceBRG::is_eigen_container< T >::value, char >::type  = 0> bool IceBRG::is_monotonically_decreasing (const T &v)"

.SS "template<typename InputIterator > bool IceBRG::is_monotonically_increasing (const InputIterator &first, const InputIterator &last)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value||IceBRG::is_eigen_container< T >::value, char >::type  = 0> bool IceBRG::is_monotonically_increasing (const T &v)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::is_monotonically_increasing (const \fBIceBRG::limit_vector\fP< T, A > &v)"

.SS "template<typename T > bool IceBRG::isbad (const T &val)\fC [inline]\fP"

.SS "bool IceBRG::isbad (std::string &val)\fC [inline]\fP"

.SS "template<typename T > bool IceBRG::isgood (const T &val)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< std::numeric_limits< T >::has_infinity, T >::type *  = nullptr> bool IceBRG::isinf (Tval)\fC [inline]\fP"

.SS "bool IceBRG::isinf (const std::string &val)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< !std::numeric_limits< T >::has_infinity, T >::type *  = nullptr> bool IceBRG::isinf (const T &val)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< std::numeric_limits< T >::has_quiet_NaN, T >::type *  = nullptr> bool IceBRG::isnan (const T &val)\fC [inline]\fP"

.SS "bool IceBRG::isnan (const std::string &val)\fC [inline]\fP"

.SS "std::string IceBRG::join_path (const std::string &s1, const std::string &s2)\fC [inline]\fP"
Joins two strings together with exactly one slash between them, regardless of whether s1 begins with a slash and/or s2 ends with one\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP 
.br
\fIs2\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename\&.\&.\&. To> std::string IceBRG::join_path (const std::string &s1, const std::string &s2, const std::string &s3, To\&.\&.\&.so)\fC [inline]\fP"
Joins multiple strings together with exactly one slash between each pair, regardless of whether they begin or end with slashes\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP 
.br
\fIs2\fP 
.br
\fIs3\fP 
.br
\fIso\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "std::string IceBRG::join_strings (const std::string &s1, const std::string &s2)\fC [inline]\fP"
Concatenates two strings\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP 
.br
\fIs2\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename\&.\&.\&. To> std::string IceBRG::join_strings (const std::string &s1, const std::string &s2, const std::string &s3, To\&.\&.\&.so)\fC [inline]\fP"
Concatenates three or more strings 
.PP
\fBParameters:\fP
.RS 4
\fIs1\fP 
.br
\fIs2\fP 
.br
\fIs3\fP 
.br
\fIso\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename Tx1 , typename Ty1 , typename Ta1 , BRG_F_IS_EIGEN_OR_SCALAR(Tx1) , BRG_F_IS_EIGEN_OR_SCALAR(Ty1) , BRG_F_IS_EIGEN_OR_SCALAR(Ta1) > Tx1 IceBRG::lc_add (const Tx1 &x1, const Ty1 &y1, const Ta1 &a1)\fC [inline]\fP"

.SS "template<typename f , typename Td  = flt_type, typename Tv  = flt_type, typename Tt  = flt_type> const \fBint_type\fP IceBRG::leapfrog_step (const Td &x, const Td &y, const Td &z, const Tv &vx, const Tv &vy, const Tv &vz, Td &new_x, Td &new_y, Td &new_z, Tv &new_vx, Tv &new_vy, Tv &new_vz, const Tt &t_step, const f *accel_func)\fC [inline]\fP"

.SS "template<typename f , typename Td  = flt_type, typename Tv  = flt_type, typename Tt  = flt_type> const \fBint_type\fP IceBRG::leapfrog_step (Td &x, Td &y, Td &z, Tv &vx, Tv &vy, Tv &vz, const Tt &t_step, const f *accel_func)\fC [inline]\fP"

.SS "template<typename f , typename Tp , typename Tt  = flt_type> const \fBint_type\fP IceBRG::leapfrog_step (const Tp &p, Tp &new_p, const Tt &t_step, const f *accel_func)\fC [inline]\fP"

.SS "template<typename f , typename Tp , typename Tt  = flt_type> const \fBint_type\fP IceBRG::leapfrog_step (Tp &p, const Tt &t_step, const f *accel_func)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 > bool IceBRG::less_than (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector<bool> IceBRG::less_than (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 > std::vector<bool> IceBRG::less_than (const T2 &v1, const T1 &v2)"

.SS "template<typename T1 , typename T2 > bool IceBRG::less_than_or_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector<bool> IceBRG::less_than_or_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 > std::vector<bool> IceBRG::less_than_or_equal (const T2 &v1, const T1 &v2)"

.SS "\fBheader_t\fP IceBRG::load_header (std::istream &table_stream)\fC [inline]\fP"

.SS "\fBheader_t\fP IceBRG::load_header (const std::string &file_name)\fC [inline]\fP"

.SS "template<typename T > table_t<T> IceBRG::load_table (std::istream &fi, const charmajor_tag = \fCEigen::ColMajor\fP, const T &default_value = \fCT()\fP, size_tmin_length = \fC0\fP)"

.SS "template<typename T > table_t<T> IceBRG::load_table (const std::string &file_name, const charmajor_tag = \fCEigen::ColMajor\fP, const T &default_value = \fCT()\fP)\fC [inline]\fP"

.SS "template<typename T > void IceBRG::load_table_columns (std::istream &fi, std::map< std::string, std::vector< T > * > &column_map, const boolcase_sensitive = \fCfalse\fP, const Tdefault_value = \fCT()\fP)"

.SS "template<typename T > void IceBRG::load_table_columns (const std::string &file_name, std::map< std::string, std::vector< T > * > &column_map, const boolcase_sensitive = \fCfalse\fP, const Tdefault_value = \fCT()\fP)"

.SS "template<typename T > table_map_t<T> IceBRG::load_table_map (std::istream &fi, const Tdefault_value = \fCT()\fP)"

.SS "template<typename T > table_map_t<T> IceBRG::load_table_map (const std::string &file_name, const Tdefault_value = \fCT()\fP)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::log (Tv)"

.SS "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::log10Gaus_rand (T_gen &gen = \fCrng\fP)"

.SS "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::log10Gaus_rand (T_in &&mean, T_in &&stddev = \fC1\&.\fP, T_gen &gen = \fCrng\fP)"

.SS "\fBflt_type\fP IceBRG::magnification_alpha (const \fBflt_type\fP &m, const \fBflt_type\fP &z)"

.SS "template<typename T1 , typename A1  = std::allocator<T1>> \fBIceBRG::limit_vector\fP<T1,A1> IceBRG::make_limit_vector_from_mids (std::vector< T1, A1 >vec)"

.SS "template<typename T1 , typename A1  = std::allocator<T1>> \fBIceBRG::limit_vector\fP<T1,A1> IceBRG::make_limit_vector_from_mids (std::vector< T1, A1 > &&vec)"

.SS "template<typename T , typename A  = std::allocator<T>> std::vector<T,A> IceBRG::make_linear_limit_vector_base (const T &min, const T &max, const size_t &num_bins)"

.SS "template<typename T , typename A  = std::allocator<T>> std::vector<T,A> IceBRG::make_log_limit_vector_base (const T &min, const T &max, const size_t &num_bins)"

.SS "template<typename obj_type > void IceBRG::make_obj (\fBBRG_UNIQUE_PTR\fP< obj_type > &obj_pointer)\fC [inline]\fP"

.SS "template<typename T > table_map_t<T> IceBRG::make_table_map (const table_t< T > &data, const header_t &header)\fC [inline]\fP"

.SS "template<int_type d, typename container , typename other_container > void IceBRG::make_vector_coerce (container &vec, const other_container &other_vec)"

.SS "template<typename container > void IceBRG::make_vector_default (container &vec, const typename \fBcontainer::size_type\fP &d1)"

.SS "template<typename container , typename\&.\&.\&. Args> void IceBRG::make_vector_default (container &vec, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"

.SS "template<int_type d, typename container , typename value_type , typename other_container > void IceBRG::make_vector_default (container &vec, const value_type &val, const other_container &other_vec)"

.SS "template<typename container , typename func_type > void IceBRG::make_vector_function (container &vec, const func_type &func, const typename \fBcontainer::size_type\fP &d1)"

.SS "template<typename container , typename func_type , typename\&.\&.\&. Args> void IceBRG::make_vector_function (container &vec, const func_type &func, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"

.SS "template<int_type d, typename container , typename func_type , typename other_container > void IceBRG::make_vector_function (container &vec, const func_type &func, const other_container &other_vec)"

.SS "template<typename container , typename val_type > void IceBRG::make_vector_value (container &vec, const val_type &val, const typename \fBcontainer::size_type\fP &d1)"

.SS "template<typename container , typename val_type , typename\&.\&.\&. Args> void IceBRG::make_vector_value (container &vec, const val_type &val, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"

.SS "template<int_type d, typename container , typename value_type , typename other_container > void IceBRG::make_vector_value (container &vec, const value_type &val, const other_container &other_vec)"

.SS "template<typename container > void IceBRG::make_vector_zeroes (container &vec, const typename \fBcontainer::size_type\fP &d1)"

.SS "template<typename container , typename\&.\&.\&. Args> void IceBRG::make_vector_zeroes (container &vec, const typename \fBcontainer::size_type\fP &d1, const typename \fBcontainer::size_type\fP &d2, Args\&.\&.\&.remaining_dims)"

.SS "template<int_type d, typename container , typename value_type , typename other_container > void IceBRG::make_vector_zeroes (container &vec, const value_type &val, const other_container &other_vec)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL_OR_EIGEN(T1) , BRG_F_IS_STL_OR_EIGEN(T2) > T1 IceBRG::max (T1 &&v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 IceBRG::max (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 IceBRG::max (T1 &&v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 IceBRG::max (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 IceBRG::max (T1 &&v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_NOT_CONTAINER(T1) , BRG_F_IS_STL(T2) > T2 IceBRG::max (const T1 &v1, T2 &&v2)"

.SS "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP<T,A> IceBRG::max (multi_vector< T, A >v1, const multi_vector< T_o, A_o > &v2)"

.SS "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP<T,A> IceBRG::max (multi_vector< T, A >v1, const std::vector< T_o, A_o > &v2)"

.SS "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP<T,A> IceBRG::max (const std::vector< T, A > &v1, const multi_vector< T_o, A_o > &v2)"

.SS "template<typename T , typename T_o , typename A_o > \fBmulti_vector\fP<T_o,A_o> IceBRG::max (const Tv1, multi_vector< T_o, A_o >v2)"

.SS "template<typename T , typename A , typename T_o > \fBmulti_vector\fP<T,A> IceBRG::max (multi_vector< T, A >v1, const T_ov2)"

.SS "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > T2 IceBRG::max (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<typename T_o , typename T_i > T_o IceBRG::max_cast (const T_i &s)"

.SS "template<class T > T& IceBRG::max_ref (T &a, T &b)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type IceBRG::mean (const std::vector< T > &v)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T IceBRG::mean (const T &v)"

.SS "template<typename T , typename A > const T IceBRG::mean (const \fBIceBRG::multi_vector\fP< T, A > &v)"

.SS "const auto IceBRG::meter_per_second (boost::units::si::meter/boost::units::si::second)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL_OR_EIGEN(T1) , BRG_F_IS_STL_OR_EIGEN(T2) > T1 IceBRG::min (T1 &&v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 IceBRG::min (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_EIGEN(T1) , BRG_F_NOT_CONTAINER(T2) , typename std::enable_if<!IceBRG::is_eigen_container< T2 >::value, char >::type  = 0> T1 IceBRG::min (T1 &&v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_NOT_CONTAINER(T1) , BRG_F_IS_STL(T2) > T2 IceBRG::min (const T1 &v1, T2 &&v2)"

.SS "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP<T,A> IceBRG::min (multi_vector< T, A >v1, const multi_vector< T_o, A_o > &v2)"

.SS "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP<T,A> IceBRG::min (multi_vector< T, A >v1, const std::vector< T_o, A_o > &v2)"

.SS "template<typename T , typename A , typename T_o , typename A_o > \fBmulti_vector\fP<T,A> IceBRG::min (const std::vector< T, A > &v1, const multi_vector< T_o, A_o > &v2)"

.SS "template<typename T , typename T_o , typename A_o > \fBmulti_vector\fP<T_o,A_o> IceBRG::min (Tv1, multi_vector< T_o, A_o >v2)"

.SS "template<typename T , typename A , typename T_o > \fBmulti_vector\fP<T,A> IceBRG::min (multi_vector< T, A >v1, const T_ov2)"

.SS "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > T2 IceBRG::min (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<typename T_o , typename T_i > T_o IceBRG::min_cast (const T_i &s)"

.SS "template<class T > T& IceBRG::min_ref (T &a, T &b)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto IceBRG::multiply (const T1 &v1, const T2 &v2)"

.SS "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type IceBRG::multiply (T1 &&, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::multiply_typeof_helper\fP< T1, T2 >::type IceBRG::multiply (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1& IceBRG::multiply_equal (const T1 &t1, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & IceBRG::multiply_equal (T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & IceBRG::multiply_equal (T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1& IceBRG::multiply_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::negate (Tv)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::negate (const T &v)"

.SS "bool IceBRG::not_all_false (const std::vector< bool > &v)\fC [inline]\fP"

.SS "constexpr bool IceBRG::not_all_false (boolv)\fC [inline]\fP"

.SS "bool IceBRG::not_all_true (const std::vector< bool > &v)\fC [inline]\fP"

.SS "constexpr bool IceBRG::not_all_true (const bool &v)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 > bool IceBRG::not_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_STL(T2) > std::vector<bool> IceBRG::not_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 > std::vector<bool> IceBRG::not_equal (const T2 &v1, const T1 &v2)"

.SS "template<typename stream_type > void IceBRG::open_bin_file (stream_type &stream, const std::string &name)"

.SS "void IceBRG::open_bin_file (std::fstream &stream, const std::string &name)\fC [inline]\fP"

.SS "template<typename stream_type > void IceBRG::open_bin_file_append (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_bin_file_input (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_bin_file_io (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_bin_file_output (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_file (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_file_append (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_file_input (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_file_io (stream_type &stream, const std::string &name)"

.SS "template<typename stream_type > void IceBRG::open_file_output (stream_type &stream, const std::string &name)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator!= (const multi_vector< T1, A1 > &v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const std::vector<bool>& IceBRG::operator!= (const multi_vector< T1, A1 > &v1, const T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator!= (const T1v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator* (multi_vector< T1, A1 >v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator* (multi_vector< T1, A1 >v1, const std::vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator* (const std::vector< T1, A1 > &v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator* (multi_vector< T1, A1 >v1, T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T2, A2> IceBRG::operator* (T1v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator+ (multi_vector< T1, A1 >v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator+ (multi_vector< T1, A1 >v1, const std::vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator+ (const std::vector< T1, A1 > &v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator+ (multi_vector< T1, A1 >v1, T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T2, A2> IceBRG::operator+ (T1v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator- (multi_vector< T1, A1 >v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator- (multi_vector< T1, A1 >v1, const std::vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator- (const std::vector< T1, A1 > &v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator- (multi_vector< T1, A1 >v1, T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T2, A2> IceBRG::operator- (T1v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::operator- (multi_vector< T, A >v)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator/ (multi_vector< T1, A1 >v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator/ (multi_vector< T1, A1 >v1, const std::vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator/ (const std::vector< T1, A1 > &v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP<T1, A1> IceBRG::operator/ (multi_vector< T1, A1 >v1, T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T2, A2> IceBRG::operator/ (T1v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator< (const multi_vector< T1, A1 > &v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const std::vector<bool>& IceBRG::operator< (const multi_vector< T1, A1 > &v1, const T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator< (const T1v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator<= (const multi_vector< T1, A1 > &v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const std::vector<bool>& IceBRG::operator<= (const multi_vector< T1, A1 > &v1, T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator<= (const T1v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator== (const multi_vector< T1, A1 > &v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const std::vector<bool>& IceBRG::operator== (const multi_vector< T1, A1 > &v1, const T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator== (const T1v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator> (const multi_vector< T1, A1 > &v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const std::vector<bool>& IceBRG::operator> (const multi_vector< T1, A1 > &v1, const T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator> (const T1v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator>= (const multi_vector< T1, A1 > &v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const std::vector<bool>& IceBRG::operator>= (const multi_vector< T1, A1 > &v1, const T2v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const std::vector<bool>& IceBRG::operator>= (const T1v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::outside_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::outside_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "bool IceBRG::p1first_lt_p2first (std::pair< \fBflt_type\fP, \fBflt_type\fP >pair1, std::pair< \fBflt_type\fP, \fBflt_type\fP >pair2)"

.SS "bool IceBRG::p1first_lt_v2 (std::pair< \fBflt_type\fP, \fBflt_type\fP >pair1, \fBflt_type\fPv2)"

.SS "template<typename T > std::vector< std::vector<T> > IceBRG::pad (const std::vector< std::vector< T > > &v, const T &default_value = \fCT()\fP)"

.SS "\fBIceBRG::time_type\fP IceBRG::period (const density_profile *host, const distance_type &r, const velocity_type &vr, const velocity_type &vt = \fC0\fP)"

.SS "template<typename T  = int_type, typename T_gen  = decltype(rng)> T IceBRG::Pois_rand (T_gen &gen = \fCrng\fP)"

.SS "template<typename T  = int_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::Pois_rand (T_in &&lambda = \fC1\&.\fP, T_gen &gen = \fCrng\fP)"

.SS "template<typename T_out , typename T_in , typename std::enable_if< std::is_same< T_out, std::string >::value, char >::type  = 0> T_in & IceBRG::pop_from_istream (T_in &in, T_out &out)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 IceBRG::pow (const T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 IceBRG::pow (T1v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_SECOND_STL(T1, T2) > T2 IceBRG::pow (const T1 &v1, T2v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1,A1> IceBRG::pow (multi_vector< T1, A1 >v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP<T1,A1> IceBRG::pow (const multi_vector< T1, A1 > &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T2,A2> IceBRG::pow (const T1 &v1, multi_vector< T2, A2 >v2)"

.SS "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > T1 IceBRG::pow (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 IceBRG::pow_err (const T1 &v, T1v_err, const \fBlong_flt_type\fP &p)\fC [inline]\fP"

.SS "template<typename T , typename T_data  = typename T::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr> void IceBRG::print_pixels (std::ostream &out_stream, const T &data)"

.SS "template<typename T , typename T_data  = typename T::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr> void IceBRG::print_pixels (const std::string &file_name, const T &data)"

.SS "template<typename T , typename T_data  = typename T::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr> void IceBRG::print_pixels (std::ostream &out_stream, const T &data)"

.SS "template<typename T , typename T_data  = typename T::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr> void IceBRG::print_pixels (const std::string &file_name, const T &data)"

.SS "template<typename T , typename T_data  = typename T::value_type::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type::value_type >::value, typename T::value_type::value_type::value_type >::type *  = nullptr> void IceBRG::print_pixels (std::ostream &out_stream, const T &data)"

.SS "template<typename T , typename T_data  = typename T::value_type::value_type::value_type, typename std::enable_if< IceBRG::is_stl_container< T >::value, T >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type >::value, typename T::value_type >::type *  = nullptr, typename std::enable_if< IceBRG::is_stl_container< typename T::value_type::value_type >::value, typename T::value_type::value_type >::type *  = nullptr, typename std::enable_if<!IceBRG::is_stl_container< typename T::value_type::value_type::value_type >::value, typename T::value_type::value_type::value_type >::type *  = nullptr> void IceBRG::print_pixels (const std::string &file_name, const T &data)"

.SS "template<typename T > void IceBRG::print_table (std::ostream &out_stream, const table_t< T > &data, const header_t &header = \fCheader_t()\fP, const charmajor_tag = \fCEigen::ColMajor\fP, const charprecision = \fC10\fP)"

.SS "template<typename T > void IceBRG::print_table (const std::string &file_name, const table_t< T > &data, const header_t &header = \fCheader_t()\fP, const charmajor_tag = \fCEigen::ColMajor\fP)"

.SS "template<typename T > void IceBRG::print_table_map (std::ostream &out, const table_map_t< T > &table_map)"

.SS "template<typename T > void IceBRG::print_table_map (const std::string &file_name, const table_map_t< T > &table_map)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Scalar IceBRG::product (const T &v)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!IceBRG::is_eigen_container< T >::value, char >::type  = 0> T IceBRG::product (const Tv)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type IceBRG::product (const T &v)"

.SS "template<typename T , typename A > const T IceBRG::product (const \fBIceBRG::multi_vector\fP< T, A > &v)"

.SS "template<typename T1 , typename T2 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) > T1 IceBRG::quad_add (const T1 &v1, const T2 &v2)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , typename T3 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) , BRG_F_IS_EIGEN_OR_SCALAR(T3) > T1 IceBRG::quad_add (const T1 &v1, const T2 &v2, const T3v3)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) > T1 IceBRG::quad_add_err (const T1 &v1, const T1 &v1_err, const T2 &v2, const T2 &v2_err)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , typename T3 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) , BRG_F_IS_EIGEN_OR_SCALAR(T3) > T1 IceBRG::quad_add_err (const T1 &v1, const T1 &v1_err, const T2 &v2, const T2 &v2_err, const T3 &v3, const T3 &v3_err)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_IS_EIGEN_OR_SCALAR(T1) , BRG_F_IS_EIGEN_OR_SCALAR(T2) > T1 IceBRG::quad_sub (const T1 &v1, const T2v2)\fC [inline]\fP"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::quart (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::quart (multi_vector< T, A >v)"

.SS "template<typename f , typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > auto IceBRG::rand_container (const ffunc, const T1 &v1, const T2 &v2)"

.SS "template<typename f , typename T1 , BRG_F_IS_NULL(T1) > auto IceBRG::rand_container (const ffunc, const T1 &v1)"

.SS "template<typename f , typename T1 , typename T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > auto IceBRG::rand_container (const ffunc, const T1 &v1, const T2 &v2)"

.SS "template<typename T , typename f , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > Tout IceBRG::rand_container_of_size (const ffunc, const \fBint_type\fP &size = \fC1\fP)"

.SS "template<typename T , typename f , typename T1 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > Tout IceBRG::rand_container_of_size (const ffunc, const T1 &v1, const \fBint_type\fP &size)"

.SS "template<typename T , typename f , typename T1 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_TUPLE(Tout) , BRG_F_IS_TUPLE(T1) > Tout IceBRG::rand_container_of_size (const ffunc, const T1 &v1, const \fBint_type\fP &)"

.SS "template<typename T , typename f , typename T1 , typename T2 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > Tout IceBRG::rand_container_of_size (const ffunc, const T1 &v1, const T2 &v2, const \fBint_type\fP &size)"

.SS "template<typename T , typename f , typename T1 , typename T2 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_TUPLE(Tout) , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > Tout IceBRG::rand_container_of_size (const ffunc, const T1 &v1, const T2 &v2, const \fBint_type\fP &)"

.SS "template<typename NewType , int_type d = 1, typename OldType  = NewType> NewType IceBRG::range_coerce (const OldType &old)"
range_coerce - helper function which returns a coercion of old into NewType\&. Use this version if the lowest level container has a range constructor for a moderate performance gain\&.
.PP
\fBParameters:\fP
.RS 4
\fIold\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename T  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::Rayleigh_rand (T_gen &gen = \fCrng\fP)"

.SS "template<typename T  = flt_type, typename T_in  = flt_type, typename T_gen  = decltype(rng)> T IceBRG::Rayleigh_rand (T_in &&sigma, T_gen &gen = \fCrng\fP)"

.SS "void IceBRG::reduce_slashes (std::string &s)\fC [inline]\fP"
Replace all double and triple slashes in a string with single slashes\&. 
.PP
\fBParameters:\fP
.RS 4
\fIs\fP 
.RE
.PP

.SS "template<typename T > std::vector< std::vector<T> > IceBRG::reverse_vertical (const std::vector< std::vector< T > > &v)"

.SS "\fBint_type\fP IceBRG::round_int (\fBflt_type\fPvalue, const \fBflt_type\fP &epsilon = \fCstd::numeric_limits<\fBflt_type\fP>::epsilon()\fP)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> \fBssize_t\fP IceBRG::rsize (const T &v)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> \fBssize_t\fP IceBRG::rsize (const T &v)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, T >::type *  = nullptr> T IceBRG::runtime_ipow (Tv, \fBint_type\fPp)"

.SS "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 IceBRG::runtime_ipow (T1v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_SECOND_STL(T1, T2) > T1 IceBRG::runtime_ipow (const T1 &v1, const T2 &v2)"

.SS "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type IceBRG::runtime_ipow (const T1 &t1, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 IceBRG::runtime_ipow (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<class T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!IceBRG::is_eigen_container< T >::value, char >::type  = 0, typename std::enable_if<!boost::units::is_quantity< T >::value, char >::type  = 0> const T IceBRG::safe_d (const T &a)"

.SS "template<class T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T IceBRG::safe_d (Tarray)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::safe_d (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::safe_d (multi_vector< T, A >v)"

.SS "template<typename Ti > auto IceBRG::safe_extract_count (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_effective_count (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_error_of_mean (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_error_of_weighted_mean (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_mean (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_mean_weight (Ti &&acc)"

.SS "template<int_type n, typename Ti > auto IceBRG::safe_extract_moment (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_sum (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_sum_of_square_weights (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_sum_of_weights (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_variance (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_weighted_mean (Ti &&acc)"

.SS "template<int_type n, typename Ti > auto IceBRG::safe_extract_weighted_moment (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_weighted_sum (Ti &&acc)"

.SS "template<typename Ti > auto IceBRG::safe_extract_weighted_variance (Ti &&acc)"

.SS "template<class Ta > const Ta IceBRG::safe_pow (const Ta &a, const \fBflt_type\fP &x)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_FIRST_STL(T1, T2) > T1 IceBRG::safe_pow (T1v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_SECOND_STL(T1, T2) > T2 IceBRG::safe_pow (const T1 &v1, T2v2)"

.SS "template<typename T1 , typename A1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T1,A1> IceBRG::safe_pow (multi_vector< T1, A1 >v1, const multi_vector< T2, A2 > &v2)"

.SS "template<typename T1 , typename A1 , typename T2 > const \fBmulti_vector\fP<T1,A1> IceBRG::safe_pow (const multi_vector< T1, A1 > &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , typename A2 > const \fBmulti_vector\fP<T2,A2> IceBRG::safe_pow (const T1 &v1, multi_vector< T2, A2 >v2)"

.SS "template<typename T1 , typename T2 > const T1 IceBRG::safe_quad_sub (const T1 &v1, const T2 &v2)\fC [inline]\fP"

.SS "template<class T > const T IceBRG::safe_sqrt (const T &a)"

.SS "\fBflt_type\fP IceBRG::safe_sqrt (const \fBint_type\fPa)\fC [inline]\fP"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::safe_sqrt (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::safe_sqrt (multi_vector< T, A >v)"

.SS "void IceBRG::set_zero (\fBint_type\fP &obj)\fC [inline]\fP"

.SS "void IceBRG::set_zero (\fBshort_int_type\fP &obj)\fC [inline]\fP"

.SS "void IceBRG::set_zero (\fBlong_int_type\fP &obj)\fC [inline]\fP"

.SS "void IceBRG::set_zero (\fBflt_type\fP &obj)\fC [inline]\fP"

.SS "void IceBRG::set_zero (\fBlong_flt_type\fP &obj)\fC [inline]\fP"

.SS "template<typename T > void IceBRG::set_zero (std::vector< T > &vec)\fC [inline]\fP"

.SS "template<typename T > void IceBRG::set_zero (T *&obj)\fC [inline]\fP"

.SS "template<typename obj_type > void IceBRG::set_zero (obj_type &obj)\fC [inline]\fP"

.SS "\fBIceBRG::surface_density_type\fP IceBRG::sigma_crit (const \fBflt_type\fP &z_lens, const \fBflt_type\fP &z_source)"

.SS "template<typename T , BRG_F_NOT_CONTAINER(T) > constexpr \fBshort_int_type\fP IceBRG::sign (const T &x, std::false_typeis_signed)\fC [inline]\fP"

.SS "template<typename T , BRG_F_NOT_CONTAINER(T) > constexpr \fBshort_int_type\fP IceBRG::sign (const T &x, std::true_typeis_signed)\fC [inline]\fP"

.SS "template<typename T , BRG_F_NOT_CONTAINER(T) > constexpr \fBshort_int_type\fP IceBRG::sign (const T &x)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP IceBRG::sin (const T &x)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > \fBtuples::sct_typeof_helper\fP< T1 >::type IceBRG::sin (const T1 &t1)\fC [inline]\fP"

.SS "\fBIceBRG::angle_type\fP IceBRG::skydist2d (const sky_obj *obj1, const sky_obj *obj2)"

.SS "template<typename Tr1 , typename Td1 , typename Tr2 , typename Td2 > const Tr1 IceBRG::skydist2d (const Tr1 &ra1, const Td1 &dec1, const Tr2 &ra2, const Td2 &dec2)\fC [inline]\fP"

.SS "template<typename f , typename Tin , typename Tout , BRG_F_NOT_CONTAINER(Tin) , BRG_F_NOT_CONTAINER(Tout) > Tin IceBRG::solve_grid (const f &func, const Tin &init_min_in_param, const Tin &init_max_in_param, const Tin &init_init_in_params_step, const Tout &target_out_param, const \fBflt_type\fP &init_init_precision = \fC0\&.00001\fP, const \fBflt_type\fP &search_precision = \fC0\&.1\fP)"

.SS "template<typename f , typename Tin , BRG_F_NOT_CONTAINER(Tin) > std::vector< Tin > IceBRG::solve_grid (const f &func, const std::vector< Tin > &init_min_in_params, const std::vector< Tin > &init_max_in_params, const std::vector< Tin > &init_init_in_params_step, const decltype(f()(std::vector< Tin >()))&target_out_params = \fCdecltype(f()(std::vector< Tin >()))()\fP, const \fBflt_type\fP &init_init_precision = \fC0\&.00001\fP, const \fBflt_type\fP &search_precision = \fC0\&.1\fP, const std::vector< \fBflt_type\fP > &init_out_params_weight = \fCstd::vector< \fBflt_type\fP >( 0 )\fP)"

.SS "template<typename f , typename Tin , typename Tout , BRG_F_NOT_CONTAINER(Tin) , BRG_F_NOT_CONTAINER(Tout) > Tin IceBRG::solve_grid (const f &func, const Tin &init_min_in_params, const Tin &init_max_in_params, const \fBint_type\fP &num_search_steps, const Tout &target_out_params, const \fBflt_type\fP &init_init_precision = \fC0\&.00001\fP, const \fBflt_type\fP &search_precision = \fC0\&.1\fP)"

.SS "template<typename f , typename Tin , typename Tout , BRG_F_NOT_CONTAINER(Tin) , BRG_F_NOT_CONTAINER(Tout) > std::vector<Tin> IceBRG::solve_grid (const f &func, const std::vector< Tin > &init_min_in_params, const std::vector< Tin > &init_max_in_params, const \fBint_type\fP &num_search_steps, const std::vector< Tout > &target_out_params, const \fBflt_type\fP &init_init_precision = \fC0\&.00001\fP, const \fBflt_type\fP &search_precision = \fC0\&.1\fP, const std::vector< \fBflt_type\fP > &out_params_weight = \fCstd::vector< \fBflt_type\fP >( 0 )\fP)"

.SS "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > const T IceBRG::solve_iterate (const f &func, const T &init_param = \fC0\fP, const \fBint_type\fPslowdown = \fC1\fP, const \fBflt_type\fP &precision = \fC0\&.0001\fP, const \fBint_type\fPmax_counter = \fC10000\fP)\fC [inline]\fP"

.SS "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > T IceBRG::solve_MCMC (const f &func, const T &init_in_params, const T &init_min_in_params, const T &init_max_in_params, const T &init_in_param_step_sigmas, const \fBint_type\fP &max_steps = \fC1000000\fP, const \fBint_type\fP &annealing_period = \fC100000\fP, const \fBflt_type\fP &annealing_factor = \fC4\fP)"
Attempts to find the minimum output value for the passed function using a Metropolis-Hastings MCMC algorithm with simulated annealing\&.
.PP
\fBParameters:\fP
.RS 4
\fIfunc\fP 
.br
\fIinit_in_param\fP 
.br
\fIinit_min_in_param\fP 
.br
\fIinit_max_in_param\fP 
.br
\fIinit_in_param_step_sigma\fP 
.br
\fIresult_in_param\fP 
.br
\fIresult_out_param\fP 
.br
\fImax_steps\fP 
.br
\fIannealing_period\fP 
.br
\fIannealing_factor\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP
Attempts to find the minimum output value for the passed function using a Metropolis-Hastings MCMC algorithm with simulated annealing\&. Vector version
.PP
\fBParameters:\fP
.RS 4
\fIfunc\fP 
.br
\fIinit_in_param\fP 
.br
\fIinit_min_in_param\fP 
.br
\fIinit_max_in_param\fP 
.br
\fIinit_in_param_step_sigma\fP 
.br
\fIresult_in_param\fP 
.br
\fIresult_out_param\fP 
.br
\fImax_steps\fP 
.br
\fIannealing_period\fP 
.br
\fIannealing_factor\fP 
.RE
.PP
\fBReturns:\fP
.RS 4
.RE
.PP

.SS "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > T IceBRG::solve_sd (const f &func, const T &init_in_params, const \fBflt_type\fP &precision = \fC0\&.00001\fP, const \fBflt_type\fP &lambda = \fC0\&.1\fP, const \fBflt_type\fP &cusp_override_power = \fC0\fP, const \fBint_type\fPmax_steps = \fC10000\fP)"

.SS "template<typename f , typename T , BRG_F_NOT_CONTAINER(T) > std::vector< T > IceBRG::solve_sd (const f &func, const std::vector< T > &init_in_params, const \fBflt_type\fP &precision = \fC0\&.00001\fP, const \fBflt_type\fP &lambda = \fC0\&.1\fP, const \fBflt_type\fP &cusp_override_power = \fC0\fP, const \fBint_type\fPmax_steps = \fC10000\fP)"

.SS "bool IceBRG::some_true_some_false (const std::vector< bool > &v)\fC [inline]\fP"

.SS "constexpr bool IceBRG::some_true_some_false (const bool &v)\fC [inline]\fP"

.SS "template<typename Tr , typename Tstddev > \fBflt_type\fP IceBRG::spherical_Gaus_pdf (const Tr &r, const Tstddev &stddev)\fC [inline]\fP"

.SS "template<typename Tr > \fBflt_type\fP IceBRG::spherical_Gaus_pdf (const Tr &r)\fC [inline]\fP"

.SS "template<typename T_out , typename T_in > std::vector<T_out> IceBRG::split_line (T_in &&line_data, const T_out &default_value = \fCT_out()\fP, const size_t &min_length = \fC0\fP)\fC [inline]\fP"

.SS "std::vector< std::string > IceBRG::split_on_whitespace (const std::string &sentence)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> auto IceBRG::sqrt (const T &x)"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::sqrt (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::sqrt (multi_vector< T, A >v)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > \fBtuples::sqrt_typeof_helper\fP< T1 >::type IceBRG::sqrt (const T1 &t1)\fC [inline]\fP"

.SS "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 IceBRG::sqrt_err (const T1 &v, T1v_err)\fC [inline]\fP"

.SS "template<typename T , BRG_F_IS_STL(T) > T IceBRG::square (Tv)"

.SS "template<typename T , typename A > const \fBmulti_vector\fP<T,A> IceBRG::square (multi_vector< T, A >v)"

.SS "template<typename T1 , BRG_F_IS_EIGEN_OR_SCALAR(T1) > T1 IceBRG::square_err (T1v, T1v_err)\fC [inline]\fP"

.SS "template<typename T , BRG_F_IS_CONTAINER(T) > \fBint_type\fP IceBRG::ssize (const T &container)"

.SS "IceBRG::static_assert (is_boost_tuple< boost::tuple< double, double >>::value, 'ERROR: is_boost_tuple isn't working for tuples\&.')"

.SS "IceBRG::static_assert (is_boost_tuple< boost::tuple< double, double > & >::value, 'ERROR: is_boost_tuple isn't working for tuple references\&.')"

.SS "IceBRG::static_assert (is_boost_tuple< boost::tuples::cons< double, boost::tuples::null_type >>::value, 'ERROR: is_boost_tuple isn't cons lists\&.')"

.SS "IceBRG::static_assert (is_boost_tuple< boost::tuples::cons< double, boost::tuples::null_type > & >::value, 'ERROR: is_boost_tuple isn't cons list references\&.')"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type IceBRG::std (const T &v)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T IceBRG::std (const T &v)"

.SS "template<typename T , typename A > const T IceBRG::std (const \fBIceBRG::multi_vector\fP< T, A > &v)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type IceBRG::stddev (const T &v)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T IceBRG::stddev (const T &v)"

.SS "template<typename T , typename A > const T IceBRG::stddev (const \fBIceBRG::multi_vector\fP< T, A > &v)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type IceBRG::stderr (const T &v)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if< IceBRG::is_eigen_container< T >::value, char >::type  = 0> T IceBRG::stderr (const T &v)"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > auto IceBRG::subtract (const T1 &v1, const T2 &v2)"

.SS "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type IceBRG::subtract (T1 &&, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > \fBtuples::subtract_typeof_helper\fP< T1, T2 >::type IceBRG::subtract (const T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1& IceBRG::subtract_equal (const T1 &t1, T2 &&)\fC [inline]\fP"

.SS "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & IceBRG::subtract_equal (T1 &t1, const T2 &t2)\fC [inline]\fP"

.SS "template<typename T1 , typename T2 , BRG_F_NEITHER_STL(T1, T2) > T1 & IceBRG::subtract_equal (T1 &v1, const T2 &v2)"

.SS "template<typename T1 , typename T2 , BRG_F_BOTH_STL(T1, T2) > T1& IceBRG::subtract_equal (const T1 &v1, const T2 &v2)"

.SS "template<typename T , typename std::enable_if<!IceBRG::is_stl_container< T >::value, char >::type  = 0, typename std::enable_if<!IceBRG::is_eigen_container< T >::value, char >::type  = 0> T::Scalar IceBRG::sum (const T &v)"

.SS "template<typename T , typename std::enable_if< IceBRG::is_stl_container< T >::value, char >::type  = 0> T::value_type IceBRG::sum (const T &v)"

.SS "template<typename T , typename A > const T IceBRG::sum (const \fBIceBRG::multi_vector\fP< T, A > &v)"

.SS "template<typename T , typename A > void IceBRG::swap (multi_vector< T, A > &v1, multi_vector< T, A > &v2)"

.SS "template<typename T , typename std::enable_if< boost::units::is_quantity< T >::value, char >::type  = 0, typename std::enable_if<!is_boost_tuple< T >::value, char >::type  = 0> \fBflt_type\fP IceBRG::tan (const T &x)"

.SS "template<class T1 , BRG_F_IS_NULL(T1) > \fBtuples::sct_typeof_helper\fP< T1 >::type IceBRG::tan (const T1 &t1)\fC [inline]\fP"

.SS "\fBIceBRG::time_type\fP IceBRG::tfa (const \fBflt_type\fP &z)"

.SS "\fBIceBRG::time_type\fP IceBRG::tfz (const \fBflt_type\fP &z)"

.SS "template<typename T > std::vector< std::vector<T> > IceBRG::transpose (const std::vector< std::vector< T > > &v, const T &default_value = \fCT()\fP)"

.SS "template<typename streamtype > void IceBRG::trim_comments_all_at_top (streamtype &stream)"

.SS "template<typename streamtype > void IceBRG::trim_comments_one_line (streamtype &stream)"
Global function declarations 
.SS "template<typename f > void IceBRG::trinary_for_each (const f &func, const boost::tuples::null_type &, const boost::tuples::null_type &)\fC [inline]\fP"

.SS "template<typename f , class Th , class Tt , typename T2 , typename T3 > void IceBRG::trinary_for_each (const f &func, const boost::tuples::cons< Th, Tt > &t1, T2 &&t2, T3 &&t3)\fC [inline]\fP"

.SS "template<typename f , class Th , class Tt , typename T2 , typename T3 > void IceBRG::trinary_for_each (const f &func, boost::tuples::cons< Th, Tt > &t1, T2 &&t2, T3 &&t3)\fC [inline]\fP"

.SS "template<typename f > void IceBRG::unary_for_each (const f &func, const boost::tuples::null_type &)\fC [inline]\fP"

.SS "template<typename f , class Th , class Tt > void IceBRG::unary_for_each (const f &func, const boost::tuples::cons< Th, Tt > &t1)\fC [inline]\fP"

.SS "template<typename f , class Th , class Tt > void IceBRG::unary_for_each (const f &func, boost::tuples::cons< Th, Tt > &t1)\fC [inline]\fP"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::under_limits (const T &val, const std::vector< T, A > &vec)"

.SS "template<typename T , typename A  = std::allocator<T>> bool IceBRG::under_limits (const T &val, const \fBIceBRG::limit_vector\fP< T, A > &vec)"

.SS "template<typename Tout , typename Tin , typename Tout_copy  = Tout, typename std::enable_if< boost::units::is_quantity< Tout_copy >::value, char >::type  = 0> Tout IceBRG::units_cast (const Tin &x)"

.SS "const std::vector<bool> IceBRG::v_not (std::vector< bool >v)\fC [inline]\fP"

.SS "template<typename T > const T IceBRG::v_not (Tv)\fC [inline]\fP"

.SS "const bool IceBRG::v_not (const boolv)\fC [inline]\fP"

.SS "template<typename T , typename std::enable_if<!std::is_same< T, any_units_type >::value &&boost::units::is_quantity< T >::value, char >::type  = 0> \fBflt_type\fP IceBRG::value_of (const T &x)"

.SS "template<typename Tstored , typename T , typename std::enable_if< std::is_same< T, any_units_type >::value, char >::type  = 0> \fBflt_type\fP IceBRG::value_of (const T &x)"

.SS "template<typename Ta , typename Tb , BRG_F_NOT_CONTAINER(Ta) , BRG_F_NOT_CONTAINER(Tb) > Ta IceBRG::weighted_dist (const std::vector< Ta > &a, const std::vector< Tb > &b)\fC [inline]\fP"

.SS "template<typename Ta , typename Tb , typename Tc , BRG_F_NOT_CONTAINER(Ta) , BRG_F_NOT_CONTAINER(Tb) , BRG_F_NOT_CONTAINER(Tc) > Ta IceBRG::weighted_dist (const std::vector< Ta > &a, const std::vector< Tb > &b, const std::vector< Tc > &c)\fC [inline]\fP"

.SS "\fBflt_type\fP IceBRG::zfa (const \fBflt_type\fP &a)"

.SS "\fBflt_type\fP IceBRG::zft (const time_type &t)"

.SH "Variable Documentation"
.PP 
.SS "constexpr \fBflt_type\fP IceBRG::default_c = 6\&."

.SS "constexpr \fBflt_type\fP IceBRG::default_tau_factor = 2\&."

.SS "constexpr \fBflt_type\fP IceBRG::delta_c = 1\&.686"

.SS "\fBerror_behavior_type\fP IceBRG::error_behavior = error_behavior_type::WARN"

.SS "IceBRG::f_in_2"

.SS "constexpr \fBflt_type\fP IceBRG::Gc = 6\&.67384e-11"

.SS "const auto IceBRG::kg = \fBkilogram\fP"

.SS "const auto IceBRG::kilogram = boost::units::si::kilogram"

.SS "const auto IceBRG::m = \fBmeter\fP"

.SS "constexpr \fBflt_type\fP IceBRG::mag_lens_T_max = 4\&.0"

.SS "constexpr \fBflt_type\fP IceBRG::mag_lens_T_min = 2\&.0"

.SS "constexpr \fBflt_type\fP IceBRG::mag_m_counting_max = 24\&.7"

.SS "constexpr \fBflt_type\fP IceBRG::mag_m_counting_min = 19"

.SS "constexpr \fBflt_type\fP IceBRG::mag_m_max = 24\&.7"

.SS "constexpr \fBflt_type\fP IceBRG::mag_m_min = 20"

.SS "constexpr \fBflt_type\fP IceBRG::mag_m_step = 0\&.1"

.SS "constexpr \fBflt_type\fP IceBRG::mag_min_count = 0\&.1"

.SS "constexpr \fBflt_type\fP IceBRG::mag_z_max = 4\&.0"

.SS "constexpr \fBflt_type\fP IceBRG::mag_z_min = 0\&.2"

.SS "constexpr \fBflt_type\fP IceBRG::mag_z_step = 0\&.01"

.SS "const auto IceBRG::meter = boost::units::si::meter"

.SS "const \fBflt_type\fP& IceBRG::min_x = 0\&.000001"

.SS "const auto IceBRG::mps = \fBmeter_per_second\fP"

.SS "constexpr \fBflt_type\fP IceBRG::n_s = 0\&.971"

.SS "constexpr \fBflt_type\fP IceBRG::Omega_b = 0\&.0472"

.SS "constexpr \fBflt_type\fP IceBRG::Omega_k = 0"

.SS "constexpr \fBflt_type\fP IceBRG::Omega_l = 1 - \fBOmega_k\fP - \fBOmega_m\fP - \fBOmega_r\fP"

.SS "constexpr \fBflt_type\fP IceBRG::Omega_m = 0\&.288"

.SS "constexpr \fBflt_type\fP IceBRG::Omega_r = 0\&.000086"

.SS "const auto IceBRG::rad = \fBradian\fP"

.SS "const auto IceBRG::radian = boost::units::si::radian"

.SS "std::ranlux48 IceBRG::rng"

.SS "const auto IceBRG::s = \fBsecond\fP"

.SS "const auto IceBRG::second = boost::units::si::second"

.SS "constexpr \fBflt_type\fP IceBRG::sigma_8 = 0\&.830"

.SS "constexpr \fBflt_type\fP IceBRG::test_fudge_factor = 1\&."

.SS "constexpr \fBflt_type\fP IceBRG::virial_density_factor = 200\&."

.SH "Author"
.PP 
Generated automatically by Doxygen for CFHTLenS_Magnification from the source code\&.
