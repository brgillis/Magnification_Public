.TH "/disk2/brg/git/Magnification_Public/src/lib/IceBRG_main/container/tuple.hpp" 3 "Thu Jul 9 2015" "Version 0.9.2" "CFHTLenS_Magnification" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/disk2/brg/git/Magnification_Public/src/lib/IceBRG_main/container/tuple.hpp \- 
.SH SYNOPSIS
.br
.PP
\fC#include <type_traits>\fP
.br
\fC#include <utility>\fP
.br
\fC#include <boost/tuple/tuple\&.hpp>\fP
.br
\fC#include <boost/type_traits/is_convertible\&.hpp>\fP
.br
\fC#include 'IceBRG_main/container/is_container\&.hpp'\fP
.br
\fC#include 'IceBRG_main/units/units\&.hpp'\fP
.br
\fC#include 'IceBRG_main/vector/elementwise_functions\&.hpp'\fP
.br

.SS "Data Structures"

.in +1c
.ti -1c
.RI "struct \fBIceBRG::tuples::add_typeof_helper< T1, T2, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::add_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::add_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_NOT_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::add_typeof_helper< T1, T2, BRG_S_NOT_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::add_typeof_helper< boost::tuples::null_type, T, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::add_typeof_helper< T, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::add_typeof_helper< boost::tuples::null_type, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::subtract_typeof_helper< T1, T2, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::subtract_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::subtract_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_NOT_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::subtract_typeof_helper< T1, T2, BRG_S_NOT_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::subtract_typeof_helper< boost::tuples::null_type, T, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::subtract_typeof_helper< T, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::subtract_typeof_helper< boost::tuples::null_type, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::multiply_typeof_helper< T1, T2, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::multiply_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::multiply_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_NOT_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::multiply_typeof_helper< T1, T2, BRG_S_NOT_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::multiply_typeof_helper< boost::tuples::null_type, T, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::multiply_typeof_helper< T, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::multiply_typeof_helper< boost::tuples::null_type, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::divide_typeof_helper< T1, T2, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::divide_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::divide_typeof_helper< T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_NOT_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::divide_typeof_helper< T1, T2, BRG_S_NOT_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::divide_typeof_helper< boost::tuples::null_type, T, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::divide_typeof_helper< T, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::divide_typeof_helper< boost::tuples::null_type, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::sqrt_typeof_helper< T1, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::sqrt_typeof_helper< T1, BRG_S_IS_TUPLE(T1)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::sqrt_typeof_helper< boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::ipow_typeof_helper< p, T1, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::ipow_typeof_helper< p, T1, BRG_S_IS_TUPLE(T1)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::ipow_typeof_helper< p, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::sct_typeof_helper< T1, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::sct_typeof_helper< T1, BRG_S_IS_TUPLE(T1)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::sct_typeof_helper< boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::asct_typeof_helper< T1, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::asct_typeof_helper< T1, BRG_S_IS_TUPLE(T1)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::asct_typeof_helper< boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::unary_rand_typeof_helper< f, T1, Enable1 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::unary_rand_typeof_helper< f, T1, BRG_S_IS_TUPLE(T1)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::unary_rand_typeof_helper< f, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::binary_rand_typeof_helper< f, T1, T2, Enable1, Enable2 >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::binary_rand_typeof_helper< f, T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::binary_rand_typeof_helper< f, T1, T2, BRG_S_IS_TUPLE(T1), BRG_S_NOT_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::binary_rand_typeof_helper< f, T1, T2, BRG_S_NOT_TUPLE(T1), BRG_S_IS_TUPLE(T2)>\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::binary_rand_typeof_helper< f, boost::tuples::null_type, T, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::binary_rand_typeof_helper< f, T, boost::tuples::null_type, void >\fP"
.br
.ti -1c
.RI "struct \fBIceBRG::tuples::binary_rand_typeof_helper< f, boost::tuples::null_type, boost::tuples::null_type, void >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBIceBRG\fP"
.br
.ti -1c
.RI "namespace \fBIceBRG::tuples\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename Th , typename Tt > boost::tuples::cons< Th, Tt > \fBIceBRG::tuples::make_cons\fP (Th &&h, Tt &&t)"
.br
.RI "\fIHelper function to construct a cons list with argument deduction\&. \fP"
.ti -1c
.RI "template<typename f > void \fBIceBRG::unary_for_each\fP (const f &func, const boost::tuples::null_type &)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt > void \fBIceBRG::unary_for_each\fP (const f &func, const boost::tuples::cons< Th, Tt > &t1)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt > void \fBIceBRG::unary_for_each\fP (const f &func, boost::tuples::cons< Th, Tt > &t1)"
.br
.ti -1c
.RI "template<typename f > void \fBIceBRG::binary_for_each\fP (const f &func, const boost::tuples::null_type &, const boost::tuples::null_type &)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 > void \fBIceBRG::binary_for_each\fP (const f &func, const boost::tuples::cons< Th, Tt > &t1, T2 &&t2)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 > void \fBIceBRG::binary_for_each\fP (const f &func, boost::tuples::cons< Th, Tt > &t1, T2 &&t2)"
.br
.ti -1c
.RI "template<typename f > void \fBIceBRG::trinary_for_each\fP (const f &func, const boost::tuples::null_type &, const boost::tuples::null_type &)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 , typename T3 > void \fBIceBRG::trinary_for_each\fP (const f &func, const boost::tuples::cons< Th, Tt > &t1, T2 &&t2, T3 &&t3)"
.br
.ti -1c
.RI "template<typename f , class Th , class Tt , typename T2 , typename T3 > void \fBIceBRG::trinary_for_each\fP (const f &func, boost::tuples::cons< Th, Tt > &t1, T2 &&t2, T3 &&t3)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBIceBRG::add\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > tuples::add_typeof_helper< T1, 
.br
T2 >::type \fBIceBRG::add\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBIceBRG::subtract\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > tuples::subtract_typeof_helper
.br
< T1, T2 >::type \fBIceBRG::subtract\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBIceBRG::multiply\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > tuples::multiply_typeof_helper
.br
< T1, T2 >::type \fBIceBRG::multiply\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBIceBRG::divide\fP (T1 &&, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > tuples::divide_typeof_helper
.br
< T1, T2 >::type \fBIceBRG::divide\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBIceBRG::add_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBIceBRG::add_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBIceBRG::subtract_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBIceBRG::subtract_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBIceBRG::multiply_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBIceBRG::multiply_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) > const T1 & \fBIceBRG::divide_equal\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 & \fBIceBRG::divide_equal\fP (T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::abs\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::sqrt\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBIceBRG::pow\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_EITHER_IS_NULL(T1, T2) > boost::tuples::null_type \fBIceBRG::runtime_ipow\fP (const T1 &t1, T2 &&)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > T1 \fBIceBRG::runtime_ipow\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<int_type p> boost::tuples::null_type \fBIceBRG::ipow\fP (const boost::tuples::null_type &t1)"
.br
.ti -1c
.RI "template<int_type p, class T1 , BRG_F_IS_TUPLE(T1) > tuples::ipow_typeof_helper< p, 
.br
T1 >::type \fBIceBRG::ipow\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::sin\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::cos\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::tan\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::asin\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::acos\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::atan\fP (const T1 &t1)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBIceBRG::min\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<class T1 , class T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBIceBRG::max\fP (const T1 &t1, const T2 &t2)"
.br
.ti -1c
.RI "template<typename f , typename T1 , BRG_F_IS_NULL(T1) > boost::tuples::null_type \fBIceBRG::rand_container\fP (const f func, const T1 &v1)"
.br
.ti -1c
.RI "template<typename f , typename T1 , typename T2 , BRG_F_IS_NULL(T1) , BRG_F_IS_NULL(T2) > boost::tuples::null_type \fBIceBRG::rand_container\fP (const f func, const T1 &v1, const T2 &v2)"
.br
.ti -1c
.RI "template<typename T , typename f , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > boost::tuples::null_type \fBIceBRG::rand_container_of_size\fP (const f func, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > boost::tuples::null_type \fBIceBRG::rand_container_of_size\fP (const f func, const T1 &v1, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_TUPLE(Tout) , BRG_F_IS_TUPLE(T1) > Tout \fBIceBRG::rand_container_of_size\fP (const f func, const T1 &v1, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename T2 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_NULL(Tout) > boost::tuples::null_type \fBIceBRG::rand_container_of_size\fP (const f func, const T1 &v1, const T2 &v2, const \fBint_type\fP &)"
.br
.ti -1c
.RI "template<typename T , typename f , typename T1 , typename T2 , typename Tout  = typename std::decay<T>::type, BRG_F_IS_TUPLE(Tout) , BRG_F_IS_TUPLE(T1) , BRG_F_IS_TUPLE(T2) > Tout \fBIceBRG::rand_container_of_size\fP (const f func, const T1 &v1, const T2 &v2, const \fBint_type\fP &)"
.br
.in -1c
.SH "Data Structure Documentation"
.PP 
.SH "struct IceBRG::tuples::add_typeof_helper"
.PP 

.SS "template<class T1, class T2, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::add_typeof_helper< T1, T2, Enable1, Enable2 >"
Helper structure to determine the type of adding two values or tuples together\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::subtract_typeof_helper"
.PP 

.SS "template<class T1, class T2, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::subtract_typeof_helper< T1, T2, Enable1, Enable2 >"
Helper structure to determine the type of subtracting two values or tuples together\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::multiply_typeof_helper"
.PP 

.SS "template<class T1, class T2, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::multiply_typeof_helper< T1, T2, Enable1, Enable2 >"
Helper structure to determine the type of multiplying two values or tuples together\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::divide_typeof_helper"
.PP 

.SS "template<class T1, class T2, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::divide_typeof_helper< T1, T2, Enable1, Enable2 >"
Helper structure to determine the type of divideing two values or tuples together\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::sqrt_typeof_helper"
.PP 

.SS "template<class T1, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::sqrt_typeof_helper< T1, Enable1, Enable2 >"
Helper structure to determine the type of sqrting a tuple\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::ipow_typeof_helper"
.PP 

.SS "template<int_type p, class T1, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::ipow_typeof_helper< p, T1, Enable1, Enable2 >"
Helper structure to determine the type of ipowing a tuple\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::sct_typeof_helper"
.PP 

.SS "template<class T1, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::sct_typeof_helper< T1, Enable1, Enable2 >"
Helper structure to determine the type of scting a tuple\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::asct_typeof_helper"
.PP 

.SS "template<class T1, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::asct_typeof_helper< T1, Enable1, Enable2 >"
Helper structure to determine the type of scting a tuple\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::unary_rand_typeof_helper"
.PP 

.SS "template<class f, class T1, class Enable1 = void>struct IceBRG::tuples::unary_rand_typeof_helper< f, T1, Enable1 >"
Helper structure to determine the type of generating a random tuple from a function\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "struct IceBRG::tuples::binary_rand_typeof_helper"
.PP 

.SS "template<class f, class T1, class T2, class Enable1 = void, class Enable2 = void>struct IceBRG::tuples::binary_rand_typeof_helper< f, T1, T2, Enable1, Enable2 >"
Helper structure to determine the type of generating a random tuple from a function\&. This is needed since the compiler won't fully recurse function decltypes, but it will fully recurse a structure\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for CFHTLenS_Magnification from the source code\&.
